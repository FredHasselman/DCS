[
["mathematics-of-change-i.html", "A Mathematics of change I", " A Mathematics of change I Solutions to assignments in section ??. Linear and logistic growth Deterministic Chaos "],
["linear-and-logistic-growth.html", "A.1 Linear and logistic growth", " A.1 Linear and logistic growth Solutions in a spreadsheet The solutions to iterating the Linear Map and theLogistic Map in a spreadsheet can be found in this GoogleSheet. Solutions in R Coding the difference equations in Matlab and R is always easier than using a spreadsheet. One obvious way to do it is to use a counter variable representing the iterations of time in a for ... next loop. The iterations should run over a vector (which is the same concept as a row or a column in a spreadsheet: An indexed array of numbers or characters). The first entry should be the starting value, so the vector index \\(1\\) represents \\(Y_0\\). The loop can be implemented a number of ways, for example as a function which can be called from a script or the command / console window. In R working with functions is easy, and very much recommended, because it will speed up calculations considerably, and it will reduce the amount of code you need to write. You need to gain some experience with coding in R before you’ll get it right. In order to get it lean and clean (and possibly even mean as well) you’ll need a lot of experience with coding in R,therefore, we will (eventually) provide you the functions you’ll need to complete the assignments. All you have to do is figure out how to use, or modify them to suit your specific needs. To model the autocatalytic growth equations we provide a function growth.ac(), which is able to simulate all of the processes discussed in the lectures. Using just a few lines of code, each of the 4 difference equations used in the assignments can be simulated. Basically the code block below contains the solutions to the Linear Map, the stylized Logisitc Map and the Van Geert model for cognitive growth. growth.ac &lt;- function(Y0 = 0.01, r = 1, k = 1, N = 100, type = c(&quot;driving&quot;, &quot;damping&quot;, &quot;logistic&quot;, &quot;vanGeert&quot;)[1]){ # Create a vector Y of length N, which has value Y0 at Y[1] if(N&gt;1){ Y &lt;- as.numeric(c(Y0, rep(NA,N-2))) # Conditional on the value of type ... switch(type, # Iterate N steps of the difference function with values passed for Y0, k and r. driving = sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- r * Y[t] ), damping = k + sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- - r * Y[t]^2 / k), logistic = sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- r * Y[t] * ((k - Y[t]) / k)), vanGeert = sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- Y[t] * (1 + r - r * Y[t] / k)) )} return(ts(Y)) } # Call the function with default settings and r = 1.1 Y &lt;- growth.ac(r = 1.1) Some notes about this function: To select which growth process to simulate, the argument type is defined which takes the values driving (default), damping, logistic and vanGeert. The statement switch(type, ...) will iterate an equation based on the value of type. A time series object is returned due to the function ts(). This is a convenient way to represent time series data, it can also store the sample rate of the signal and start and end times. Most of the basic functions, like plot() and summary() will recognise a time series object when it is passed as an argument and use settings appropriate for time series data. The sapply() function iterates \\(t\\) from \\(1\\) to the number of elements in \\(Y\\) (seq_along(Y)) and then applies the function. The double headed arrow &lt;&lt;- is necessary because we want to update vector \\(Y\\), which is defined outside the sapply() environment. The time series object The time series object is expected to have a time-dimension on the x-axis. This is very convenient, because R will generate the time axis for you by looking at the time series properties attribute of the object. Even though we are not working with measurement ourcomes, consider a value at a time-index in a time series object a sample: Start - The value of time at the first sample in the series (e.g., \\(0\\), or \\(1905\\)) End - The value of time at the last sample in the series (e.g., \\(100\\), or \\(2005\\)) Frequency - The amount of time that passed between two samples, or, the sample rate (e.g., \\(0.5\\), or \\(10\\)) Examples of using the time series object. # Get sample rate info tsp(Y) ## [1] 1 100 1 # Extract the time vector time(Y) ## Time Series: ## Start = 1 ## End = 100 ## Frequency = 1 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ## [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 ## [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ## [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 For now, these values are in principle all arbitrary units (a.u.). These settings only make sense if they represent the parameters of an actual measurement procedure. It is easy to adjust the time vector, by assigning new values using tsp() (values have to be possible given the timeseries length). For example, suppose the sampling frequency was \\(0.1\\) instead of \\(1\\) and the Start time was \\(10\\) and End time was \\(1000\\). # Assign new values tsp(Y) &lt;- c(10, 1000, .1) # Time axis is automatically adjusted time(Y) ## Time Series: ## Start = 10 ## End = 1000 ## Frequency = 0.1 ## [1] 10 20 30 40 50 60 70 80 90 100 110 120 130 140 ## [15] 150 160 170 180 190 200 210 220 230 240 250 260 270 280 ## [29] 290 300 310 320 330 340 350 360 370 380 390 400 410 420 ## [43] 430 440 450 460 470 480 490 500 510 520 530 540 550 560 ## [57] 570 580 590 600 610 620 630 640 650 660 670 680 690 700 ## [71] 710 720 730 740 750 760 770 780 790 800 810 820 830 840 ## [85] 850 860 870 880 890 900 910 920 930 940 950 960 970 980 ## [99] 990 1000 Plotting a ts object as a time series Depending on which packages you use, there will be different settings applied to time series objects created by ts(). Below are some examples of differences between plotting routines. require(lattice) # Needed for plotting ## Loading required package: lattice require(latticeExtra) # Needed for plotting ## Loading required package: latticeExtra ## Loading required package: RColorBrewer # stats::plot.ts plot(growth.ac(r = -.9), lwd = 2, main = &quot;stats::plot.ts&quot;) # lattice::xyplot.ts xyplot(growth.ac(r = -.9), lwd = 2, main = &quot;lattice::xyplot.ts&quot;) Plotting multiple time series in one figure Plot multiple timeseries in frames with plot.ts() in package::stats. This function takes a matrix as input, here we use cbind( ... ). # stats::plot.ts plot(cbind(growth.ac(r = 0.9), growth.ac(r = 1.0), growth.ac(r = -0.8) ), yax.flip = TRUE, ann = FALSE, col = &quot;blue&quot;, frame.plot = TRUE) title(main = expression(paste(&quot;Unrestricted Growth: &quot;,Y[t+1]==r*Y[t])), ylab = &quot;| r = -0.8 | r = 1 | r = 0.9 |&quot;, xlab = &quot;time (a.u.)&quot;) Plot multiple timeseries in one graph with ts.plot() in package::graphics. This function can handle multiple ts objects as arguments. # graphics::ts.plot ts.plot(growth.ac(r = 0.9), growth.ac(r = 1), growth.ac(r = -.8), gpars = list(xlab = &quot;time (a.u.)&quot;, ylab = expression(Y(t)), main = expression(paste(&quot;Unrestricted Growth: &quot;,Y[t+1]==r*Y[t])), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;) ) ) legend(70, -0.015, c(&quot;r = 0.9&quot;,&quot;r = 1.0&quot;, &quot;r = -0.8&quot;), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;), merge = TRUE) Use xyplot() in package::lattice to create a plot with panels. The easiest way to do this is to create a dataset in so-called “long” format. This means the variable to plot is in 1 column and other variables indicate different levels, or conditions under which the variable was observed or simulated. Function ldply() is used to generate \\(Y\\) for three different settings of \\(r\\). The values of \\(r\\) are passed as a list and after a function is applied the result is returned as a dataframe. require(plyr) # Needed for function ldply() ## Loading required package: plyr # Create a long format dataframe for various values for `r` data &lt;- ldply(c(0.9,1,-0.8), function(r) cbind.data.frame(Y = as.numeric(growth.ac(r = r)), time = as.numeric(time(growth.ac(r = r))), r = paste0(&quot;r = &quot;, r))) # Plot using the formula interface xyplot(Y ~ time | r, data = data, type = &quot;l&quot;, main = expression(paste(&quot;Unrestricted Growth: &quot;,Y[t+1]==r*Y[t]))) One can also have different panels represent different growth functions. # Create a long format dataframe for combinations of `type` and `r` param &lt;- list(driving = 1.1, damping = 0.9, logistic = 2.9, vanGeert = 1.9) # Use the `names()` function to pass the `type` string as an argument. data &lt;- ldply(seq_along(param), function(p){ cbind.data.frame(Y = as.numeric(growth.ac(r = param[[p]], type = names(param[p]))), time = as.numeric(time(growth.ac(r = param[[p]], type = names(param[p])))), type = paste0(names(param[p]), &quot; | r = &quot;, param[p])) }) # Plot using the formula interface xyplot(Y ~ time | factor(type), data = data, type = &quot;l&quot;, scales = c(relation = &quot;free&quot;), main = &quot;Four Autocatalytic Growth Models&quot;) The return plot To create a return plot the values of \\(Y\\) have to be shifted by a certain lag. The functions lead() and lag() in package::dplyr are excellent for this purpose (note that dplyr::lag() behaves different from stats::lag()). # Function lag() and lead() require(dplyr) ## Loading required package: dplyr ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:plyr&#39;: ## ## arrange, count, desc, failwith, id, mutate, rename, summarise, ## summarize ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # Get exponential growth Y1 &lt;- growth.ac(Y0 = .9, r = .9, N = 1000, type = &quot;driving&quot;) # Get logistic growth in the chaotic regime Y2 &lt;- growth.ac(r = 4, N = 1000, type = &quot;logistic&quot;) # Use the `lag` function from package `dplyr` op &lt;- par(mfrow = c(1,2), pty = &quot;s&quot;) plot(lag(Y1), Y1, xy.labels = FALSE, pch = &quot;.&quot;, xlim = c(0,1), ylim = c(0,1), xlab = &quot;Y(t)&quot;, ylab = &quot;Y(t+1)&quot;, main = expression(paste(Y[t+1]==r*Y[t]))) plot(lag(Y2), Y2, xy.labels = FALSE, pch = &quot;.&quot;, xlim = c(0,1), ylim = c(0,1), xlab = &quot;Y(t)&quot;, ylab = &quot;Y(t+1)&quot;, main = expression(paste(Y[t+1]==r*Y[t]*(1-Y[t])))) par(op) Use l_ply() from package::plyr to create return plots with different lags. The l_ before ply means the function will take a list as input to a function, but it will not expect any data to be returned, for example in the case of a function that is used to plot something. # Explore different lags op &lt;- par(mfrow = c(1,2), pty = &quot;s&quot;) l_ply(1:4, function(l) plot(lag(Y2, n = l), Y2, xy.labels = FALSE, pch = &quot;.&quot;, xlim = c(0,1), ylim = c(0,1), xlab = &quot;Y(t)&quot;, ylab = paste0(&quot;Y(t+&quot;,l,&quot;)&quot;), cex = .8)) par(op) A.1.1 Solutions in Matlab For Matlab we provide an example of a simple for ... next loop, which should be easy to translate to R if you want to. Linear Map %%%%%%%%%%%%%% COMPUTING TRAJECTORIES OF THE LOGISTIC MAP %%%%% %% Set these parameters to manipulate the logistic map r = 1,1; % Control parameter value Y0 = 0.01; % Initial condition N = 100; % Number of iterations %% Y = [Y0; NaN(length(1:(N-1)),1)]; % This creates a vector Y of length N % iterate values for t = 1:(N-1) Y(t+1) = r*Y(t); end %% Graphs subplot(2,1,1) % Create a graph the time series figure(1); set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y,&#39;k&#39;); xlabel(&#39;Time (discrete)&#39;) ylabel(&#39;Time Evolution of Y&#39;) title([{&#39;Linear Map&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) subplot(2,1,2) % Create a graph the return plot set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y(1:length(Y)-1),Y(2:length(Y)),&#39;.k&#39;); xlabel(&#39;Y(t)&#39;) ylabel(&#39;Y(t+1)&#39;) title([{&#39;Return Plot&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) axis square Logistic Map %%%%%%%%%%%%%% COMPUTING TRAJECTORIES OF THE LOGISTIC MAP %%%%% %% Set these parameters to manipulate the logistic map r = 4; % Control parameter value Y0 = 0.08; % Initial condition N = 100; % Number of iterations %% Y = [Y0; NaN(length(1:(N-1)),1)]; % This creates a vector Y of length N % iterate values for t = 1:(N-1) Y(t+1) = r*Y(t)*(1-Y(t)); end %% Graphs subplot(2,1,1) % Create a graph the time series figure(1); set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y,&#39;k&#39;); xlabel(&#39;Time (discrete)&#39;) ylabel(&#39;Time Evolution of Y&#39;) title([{&#39;Logisitc Map&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) subplot(2,1,2) % Create a graph the return plot set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y(1:length(Y)-1),Y(2:length(Y)),&#39;.k&#39;); xlabel(&#39;Y(t)&#39;) ylabel(&#39;Y(t+1)&#39;) title([{&#39;Return Plot&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) axis square Solution Logistic Map - Matlab -->"],
["mathematics-of-change-ii.html", "B Mathematics of Change II", " B Mathematics of Change II Solutions to assignments in section ?? Time-varying parameters Predator-prey dynamics "],
["time-varying-parameters.html", "B.1 Time-varying parameters", " B.1 Time-varying parameters Solutions in a spreadsheet Van Geert, including jumps and stages. B.1.1 Solutions in R The growth model by Van Geert (1991) Different values for r: library(plyr) # Parameters rs &lt;- c(1.2, 2.2, 2.5, 2.7, 2.9, 3) # Plot op &lt;- par(mfrow=c(1,2)) l_ply(rs,function(r){plot(growth.ac(r = r, Y0 = 0.01, type = &quot;vanGeert&quot;), ylim = c(0,1.4), ylab = &quot;L(t)&quot;, main = paste(&quot;r =&quot;,r))}) par(op) Different values for \\(k\\) reveal that the dispersion of values (variance) increases if the carrying capacity increases. This occurs because we are dealing with nonlinear changes to the values of \\(Y\\) and if larger values of \\(Y\\) are allowed by a hihger \\(k\\), these values will be amplified once they occur. # Parameters ks &lt;- c(0.5, 0.75, 1, 1.5) # Plot op &lt;- par(mfrow=c(1,2)) l_ply(ks,function(k){plot(growth.ac(r = 2.9, k = k, Y0 = 0.01, type = &quot;vanGeert&quot;), ylim = c(0, 2), ylab = &quot;L(t)&quot;, main = paste(&quot;k =&quot;,k))}) par(op) Stages and Jumps growth.ac.cond &lt;- function(Y0 = 0.01, r = 0.1, k = 2, cond = cbind.data.frame(Y = 0.2, par = &quot;r&quot;, val = 2), N = 100){ # Create a vector Y of length N, which has value Y0 at Y[1] Y &lt;- c(Y0, rep(NA, N-1)) # Iterate N steps of the difference equation with values passed for Y0, k and r. cnt &lt;- 1 for(t in seq_along(Y)){ # Check if the current value of Y is greater than the threshold for the current conditional rule in cond if(Y[t] &gt; cond$Y[cnt]){ # If the threshold is surpassed, change the parameter settings by evaluating: cond$par = cond$val eval(parse(text = paste(cond$par[cnt], &quot;=&quot;, cond$val[cnt]))) # Update the counter if there is another conditional rule in cond if(cnt &lt; nrow(cond)){cnt &lt;- cnt + 1} } # Van Geert growth model Y[[t+1]] &lt;- Y[t] * (1 + r - r * Y[t] / k) } return(ts(Y)) } # Plot with the default settings (same as first step in the assignment) xyplot(growth.ac.cond()) The ‘trick’ used here is to define the function such that it can take a set of conditional rules and apply them sequentially during the iterations. The conditiona rule is passed as a data.frame, but one could also use a list object. (cond &lt;- cbind.data.frame(Y = c(0.2, 0.6), par = c(&quot;r&quot;, &quot;r&quot;), val = c(0.5, 0.1))) ## Y par val ## 1 0.2 r 0.5 ## 2 0.6 r 0.1 xyplot(growth.ac.cond(cond=cond)) Or, combine a change of r and a change of k (cond &lt;- cbind.data.frame(Y = c(0.2, 1.99), par = c(&quot;r&quot;, &quot;k&quot;), val = c(0.5, 3))) ## Y par val ## 1 0.20 r 0.5 ## 2 1.99 k 3.0 xyplot(growth.ac.cond(cond=cond)) # A fantasy growth process (cond &lt;- cbind.data.frame(Y = c(0.1, 1.99, 1.999, 2.5, 2.9), par = c(&quot;r&quot;, &quot;k&quot;, &quot;r&quot;, &quot;r&quot;,&quot;k&quot;), val = c(0.3, 3, 0.9, 0.1, 1.3))) ## Y par val ## 1 0.100 r 0.3 ## 2 1.990 k 3.0 ## 3 1.999 r 0.9 ## 4 2.500 r 0.1 ## 5 2.900 k 1.3 xyplot(growth.ac.cond(cond=cond)) Connected Growers Somewhat more realstic would be to model a change of r as dependent on the values of another process. The proper ‘dynamical’ way to do this would be to define a coupled system of difference or differential equations in which the interaction dynamics regulate growth. An example is the predator-prey system discussed in the next assignment. Using the ‘conditional’ rules on a number of seperate processes will ‘work’ as a model, but it isn’t exactly what is meant by interaction dynamics, or multiplicative interactions. Basically, these processes will be independent and non-interacting. The conditional rules that change the parameters are ‘given’. # Generate 3 timeseries Y1 &lt;- growth.ac(k = 2, r =.2, type = &quot;vanGeert&quot;) # Y2 and Y3 start at r = 0.001 Y3 &lt;- Y2 &lt;- growth.ac(k = 2, r = 0.001, type = &quot;vanGeert&quot;) # Y2 and Y3 start when k is approached c1 &lt;- 1.6 c2 &lt;- 2.2 Y2[Y1 &gt; c1] &lt;- growth.ac(r = .3, k = 3, type = &quot;vanGeert&quot;, N = sum(Y1 &gt; c1)) Y3[Y2 &gt; c2] &lt;- growth.ac(r = .5, k = 4, type = &quot;vanGeert&quot;, N = sum(Y2 &gt; c2)) # Make a nice plot ts.plot(Y1, Y2, Y3, gpars = list(xlab = &quot;time (a.u.)&quot;, ylab = expression(Y(t)), main = expression(paste(&quot;&#39;Connected&#39; Growers &quot;,Y[t+1]==Y[t]*(1 + r - r*Y[t]))), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;) ) ) legend(1, 3.8, c(&quot;Y1(0): r = .2&quot;, paste0(&quot;Y2(&quot;,which(Y1 &gt; c1)[1],&quot;): r = .3&quot;), paste0(&quot;Y3(&quot;,which(Y2 &gt; c2)[1],&quot;): r = .5&quot;)), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;), merge = TRUE) "],
["predator-prey-dynamics.html", "B.2 Predator-prey dynamics", " B.2 Predator-prey dynamics Iterating 2D Maps and Flows In order to ‘solve’ a differential equation for time using a method of numerical integration, one could code it like in the spreadsheet assignment. For R and Matlab there are so-called solvers available, functions that will do the integration for you. Look at the Examples in package deSolve. Solutions in a spreadsheet Predator-Prey Dynamics B.2.1 Solutions in R Euler’s method and more… The result of applying a method of numerical integration is called a numerical solution of the differential equation. The analytical solution is the equation which will give you a value of \\(Y\\) for any point in time, given an initial value \\(Y_0\\). Systems which have an analytical solution can be used to test the accuracy of numerical solutions. Remember that the analytical solution for the logistic equation is: \\[\\begin{equation} \\frac{K}{1 + \\left(\\frac{K}{Y_0 - 1}\\right) * e^{-r*t} } \\tag{B.1} \\end{equation}\\] We have the function growth.ac() and could easily adapt all the functions to use Euler’s method. Below is a comparison of the analytic solution with Euler’s method. # Parameter settings d &lt;- 1 N &lt;- 100 r &lt;- .1 k &lt;- 1 Y0 &lt;- 0.01 Y &lt;- as.numeric(c(Y0, rep(NA,N-1))) # Numerical integration of the logistic differential equation Y.euler1 &lt;- ts( sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- (r * Y[t] * (k - Y[t])) * d + Y[t] )) Y.euler2 &lt;- ts( sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- (r * Y[t] * (k - Y[t])) * (d+.1) + Y[t] )) ## analytical solution Y.analytic &lt;- ts( k / (1 + (k / Y0 - 1) * exp(-r*(time(Y.euler1)))) ) ts.plot(Y.analytic, Y.euler1, Y.euler2, gpars = list(xlab = &quot;time (a.u.)&quot;, ylab = expression(Y(t)), main = expression(paste(&quot;Analytic vs. Numerical:&quot;,Y[t+1]==Y[t]*(1 + r - r*Y[t]))), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;) ) ) legend(50, 0.4, c(&quot;Analytic&quot;, &quot;Euler: delta = 1.0&quot;, &quot;Euler: delta = 1.1&quot;), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;), merge = TRUE) Numerical integration The Euler setup: \\[\\begin{align} R_{t+1} &amp;= f_R(R_t,Ft) * \\Delta + R_t \\\\ F_{t+1} &amp;= f_F(R_t,F_t) * \\Delta + F_t \\end{align}\\] With the equations: \\[\\begin{align} R_{t+1} &amp;= (a-b*F_t)*R_t * \\Delta + R_t \\\\ \\\\ F_{t+1} &amp;= (c*R_t-d)*F_t * \\Delta + F_t \\end{align}\\] # Parameters N &lt;- 1000 a &lt;- d &lt;- 1 b &lt;- c &lt;- 2 R0 &lt;- F0 &lt;- 0.1 R &lt;- as.numeric(c(R0, rep(NA,N-1))) F &lt;- as.numeric(c(F0, rep(NA,N-1))) # Time constant delta &lt;- 0.01 # Numerical integration of the logistic differential equation l_ply(seq_along(R), function(t){ R[[t+1]] &lt;&lt;- (a - b * F[t]) * R[t] * delta + R[t] F[[t+1]] &lt;&lt;- (c * R[t] - d) * F[t] * delta + F[t] }) # Note different behaviour when ts() is applied xyplot(cbind(ts(R),ts(F))) xyplot(R ~ F, pch = 16) -->"],
["btasol.html", "C Basic Timeseries Analysis", " C Basic Timeseries Analysis "],
["fda1sol.html", "D Fluctuation and Disperion analyses I", " D Fluctuation and Disperion analyses I "],
["fda1so2.html", "E Fluctuation and Disperion analyses II", " E Fluctuation and Disperion analyses II "],
["RQAsol.html", "F Phase Space Reconstruction and Recurrence Quantification Analysis (RQA)", " F Phase Space Reconstruction and Recurrence Quantification Analysis (RQA) "],
["CRQAsol.html", "G Categorical and Cross-RQA (CRQA)", " G Categorical and Cross-RQA (CRQA) "],
["cuspsol.html", "H The Cusp Catasrophe Model &amp; Warning Signs", " H The Cusp Catasrophe Model &amp; Warning Signs "],
["netssol.html", "I Complex Networks", " I Complex Networks "]
]
