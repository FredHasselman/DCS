[
["mathematics-of-change-i.html", "A Mathematics of change I", " A Mathematics of change I Solutions to assignments in section ??. Linear and logistic growth Deterministic Chaos "],
["linear-and-logistic-growth.html", "A.1 Linear and logistic growth", " A.1 Linear and logistic growth Solutions in a spreadsheet The solutions to iterating the Linear Map and theLogistic Map in a spreadsheet can be found in this GoogleSheet. Solutions in R | jump to question | Coding the difference equations in Matlab and R is always easier than using a spreadsheet. One obvious way to do it is to use a counter variable representing the iterations of time in a for ... next loop. The iterations should run over a vector (which is the same concept as a row or a column in a spreadsheet: An indexed array of numbers or characters). The first entry should be the starting value, so the vector index \\(1\\) represents \\(Y_0\\). The loop can be implemented a number of ways, for example as a function which can be called from a script or the command / console window. In R working with functions is easy, and very much recommended, because it will speed up calculations considerably, and it will reduce the amount of code you need to write. You need to gain some experience with coding in R before you’ll get it right. In order to get it lean and clean (and possibly even mean as well) you’ll need a lot of experience with coding in R,therefore, we will (eventually) provide you the functions you’ll need to complete the assignments. All you have to do is figure out how to use, or modify them to suit your specific needs. To model the autocatalytic growth equations we provide a function growth.ac(), which is able to simulate all of the processes discussed in the lectures. Using just a few lines of code, each of the 4 difference equations used in the assignments can be simulated. Basically the code block below contains the solutions to the Linear Map, the stylized Logisitc Map and the Van Geert model for cognitive growth. growth.ac &lt;- function(Y0 = 0.01, r = 1, k = 1, N = 100, type = c(&quot;driving&quot;, &quot;damping&quot;, &quot;logistic&quot;, &quot;vanGeert&quot;)[1]){ # Create a vector Y of length N, which has value Y0 at Y[1] if(N&gt;1){ Y &lt;- as.numeric(c(Y0, rep(NA,N-2))) # Conditional on the value of type ... switch(type, # Iterate N steps of the difference function with values passed for Y0, k and r. driving = sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- r * Y[t] ), damping = k + sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- - r * Y[t]^2 / k), logistic = sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- r * Y[t] * ((k - Y[t]) / k)), vanGeert = sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- Y[t] * (1 + r - r * Y[t] / k)) )} return(ts(Y)) } # Call the function with default settings and r = 1.1 Y &lt;- growth.ac(r = 1.1) Some notes about this function: To select which growth process to simulate, the argument type is defined which takes the values driving (default), damping, logistic and vanGeert. The statement switch(type, ...) will iterate an equation based on the value of type. A time series object is returned due to the function ts(). This is a convenient way to represent time series data, it can also store the sample rate of the signal and start and end times. Most of the basic functions, like plot() and summary() will recognise a time series object when it is passed as an argument and use settings appropriate for time series data. The sapply() function iterates \\(t\\) from \\(1\\) to the number of elements in \\(Y\\) (seq_along(Y)) and then applies the function. The double headed arrow &lt;&lt;- is necessary because we want to update vector \\(Y\\), which is defined outside the sapply() environment. The time series object The time series object is expected to have a time-dimension on the x-axis. This is very convenient, because R will generate the time axis for you by looking at the time series properties attribute of the object. Even though we are not working with measurement ourcomes, consider a value at a time-index in a time series object a sample: Start - The value of time at the first sample in the series (e.g., \\(0\\), or \\(1905\\)) End - The value of time at the last sample in the series (e.g., \\(100\\), or \\(2005\\)) Frequency - The amount of time that passed between two samples, or, the sample rate (e.g., \\(0.5\\), or \\(10\\)) Examples of using the time series object. # Get sample rate info tsp(Y) [1] 1 100 1 # Extract the time vector time(Y) Time Series: Start = 1 End = 100 Frequency = 1 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 For now, these values are in principle all arbitrary units (a.u.). These settings only make sense if they represent the parameters of an actual measurement procedure. It is easy to adjust the time vector, by assigning new values using tsp() (values have to be possible given the timeseries length). For example, suppose the sampling frequency was \\(0.1\\) instead of \\(1\\) and the Start time was \\(10\\) and End time was \\(1000\\). # Assign new values tsp(Y) &lt;- c(10, 1000, .1) # Time axis is automatically adjusted time(Y) Time Series: Start = 10 End = 1000 Frequency = 0.1 [1] 10 20 30 40 50 60 70 80 90 100 110 120 130 140 [15] 150 160 170 180 190 200 210 220 230 240 250 260 270 280 [29] 290 300 310 320 330 340 350 360 370 380 390 400 410 420 [43] 430 440 450 460 470 480 490 500 510 520 530 540 550 560 [57] 570 580 590 600 610 620 630 640 650 660 670 680 690 700 [71] 710 720 730 740 750 760 770 780 790 800 810 820 830 840 [85] 850 860 870 880 890 900 910 920 930 940 950 960 970 980 [99] 990 1000 Plotting a ts object as a time series Depending on which packages you use, there will be different settings applied to time series objects created by ts(). Below are some examples of differences between plotting routines. require(lattice) # Needed for plotting Loading required package: lattice require(latticeExtra) # Needed for plotting Loading required package: latticeExtra Loading required package: RColorBrewer # stats::plot.ts plot(growth.ac(r = -.9), lwd = 2, main = &quot;stats::plot.ts&quot;) # lattice::xyplot.ts xyplot(growth.ac(r = -.9), lwd = 2, main = &quot;lattice::xyplot.ts&quot;) Plotting multiple time series in one figure Plot multiple timeseries in frames with plot.ts() in package::stats. This function takes a matrix as input, here we use cbind( ... ). # stats::plot.ts plot(cbind(growth.ac(r = 0.9), growth.ac(r = 1.0), growth.ac(r = -0.8) ), yax.flip = TRUE, ann = FALSE, col = &quot;blue&quot;, frame.plot = TRUE) title(main = expression(paste(&quot;Unrestricted Growth: &quot;,Y[t+1]==r*Y[t])), ylab = &quot;| r = -0.8 | r = 1 | r = 0.9 |&quot;, xlab = &quot;time (a.u.)&quot;) Plot multiple timeseries in one graph with ts.plot() in package::graphics. This function can handle multiple ts objects as arguments. # graphics::ts.plot ts.plot(growth.ac(r = 0.9), growth.ac(r = 1), growth.ac(r = -.8), gpars = list(xlab = &quot;time (a.u.)&quot;, ylab = expression(Y(t)), main = expression(paste(&quot;Unrestricted Growth: &quot;,Y[t+1]==r*Y[t])), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;) ) ) legend(70, -0.015, c(&quot;r = 0.9&quot;,&quot;r = 1.0&quot;, &quot;r = -0.8&quot;), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;), merge = TRUE) Use xyplot() in package::lattice to create a plot with panels. The easiest way to do this is to create a dataset in so-called “long” format. This means the variable to plot is in 1 column and other variables indicate different levels, or conditions under which the variable was observed or simulated. Function ldply() is used to generate \\(Y\\) for three different settings of \\(r\\). The values of \\(r\\) are passed as a list and after a function is applied the result is returned as a dataframe. require(plyr) # Needed for function ldply() Loading required package: plyr # Create a long format dataframe for various values for `r` data &lt;- ldply(c(0.9,1,-0.8), function(r) cbind.data.frame(Y = as.numeric(growth.ac(r = r)), time = as.numeric(time(growth.ac(r = r))), r = paste0(&quot;r = &quot;, r))) # Plot using the formula interface xyplot(Y ~ time | r, data = data, type = &quot;l&quot;, main = expression(paste(&quot;Unrestricted Growth: &quot;,Y[t+1]==r*Y[t]))) One can also have different panels represent different growth functions. # Create a long format dataframe for combinations of `type` and `r` param &lt;- list(driving = 1.1, damping = 0.9, logistic = 2.9, vanGeert = 1.9) # Use the `names()` function to pass the `type` string as an argument. data &lt;- ldply(seq_along(param), function(p){ cbind.data.frame(Y = as.numeric(growth.ac(r = param[[p]], type = names(param[p]))), time = as.numeric(time(growth.ac(r = param[[p]], type = names(param[p])))), type = paste0(names(param[p]), &quot; | r = &quot;, param[p])) }) # Plot using the formula interface xyplot(Y ~ time | factor(type), data = data, type = &quot;l&quot;, scales = c(relation = &quot;free&quot;), main = &quot;Four Autocatalytic Growth Models&quot;) The return plot To create a return plot the values of \\(Y\\) have to be shifted by a certain lag. The functions lead() and lag() in package::dplyr are excellent for this purpose (note that dplyr::lag() behaves different from stats::lag()). # Function lag() and lead() require(dplyr) Loading required package: dplyr Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:plyr&#39;: arrange, count, desc, failwith, id, mutate, rename, summarise, summarize The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union # Get exponential growth Y1 &lt;- growth.ac(Y0 = .9, r = .9, N = 1000, type = &quot;driving&quot;) # Get logistic growth in the chaotic regime Y2 &lt;- growth.ac(r = 4, N = 1000, type = &quot;logistic&quot;) # Use the `lag` function from package `dplyr` op &lt;- par(mfrow = c(1,2), pty = &quot;s&quot;) plot(lag(Y1), Y1, xy.labels = FALSE, pch = &quot;.&quot;, xlim = c(0,1), ylim = c(0,1), xlab = &quot;Y(t)&quot;, ylab = &quot;Y(t+1)&quot;, main = expression(paste(Y[t+1]==r*Y[t]))) plot(lag(Y2), Y2, xy.labels = FALSE, pch = &quot;.&quot;, xlim = c(0,1), ylim = c(0,1), xlab = &quot;Y(t)&quot;, ylab = &quot;Y(t+1)&quot;, main = expression(paste(Y[t+1]==r*Y[t]*(1-Y[t])))) par(op) Use l_ply() from package::plyr to create return plots with different lags. The l_ before ply means the function will take a list as input to a function, but it will not expect any data to be returned, for example in the case of a function that is used to plot something. # Explore different lags op &lt;- par(mfrow = c(1,2), pty = &quot;s&quot;) l_ply(1:4, function(l) plot(lag(Y2, n = l), Y2, xy.labels = FALSE, pch = &quot;.&quot;, xlim = c(0,1), ylim = c(0,1), xlab = &quot;Y(t)&quot;, ylab = paste0(&quot;Y(t+&quot;,l,&quot;)&quot;), cex = .8)) par(op) A.1.1 Solutions in Matlab For Matlab we provide an example of a simple for ... next loop, which should be easy to translate to R if you want to. Linear Map %%%%%%%%%%%%%% COMPUTING TRAJECTORIES OF THE LOGISTIC MAP %%%%% %% Set these parameters to manipulate the logistic map r = 1,1; % Control parameter value Y0 = 0.01; % Initial condition N = 100; % Number of iterations %% Y = [Y0; NaN(length(1:(N-1)),1)]; % This creates a vector Y of length N % iterate values for t = 1:(N-1) Y(t+1) = r*Y(t); end %% Graphs subplot(2,1,1) % Create a graph the time series figure(1); set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y,&#39;k&#39;); xlabel(&#39;Time (discrete)&#39;) ylabel(&#39;Time Evolution of Y&#39;) title([{&#39;Linear Map&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) subplot(2,1,2) % Create a graph the return plot set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y(1:length(Y)-1),Y(2:length(Y)),&#39;.k&#39;); xlabel(&#39;Y(t)&#39;) ylabel(&#39;Y(t+1)&#39;) title([{&#39;Return Plot&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) axis square Logistic Map %%%%%%%%%%%%%% COMPUTING TRAJECTORIES OF THE LOGISTIC MAP %%%%% %% Set these parameters to manipulate the logistic map r = 4; % Control parameter value Y0 = 0.08; % Initial condition N = 100; % Number of iterations %% Y = [Y0; NaN(length(1:(N-1)),1)]; % This creates a vector Y of length N % iterate values for t = 1:(N-1) Y(t+1) = r*Y(t)*(1-Y(t)); end %% Graphs subplot(2,1,1) % Create a graph the time series figure(1); set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y,&#39;k&#39;); xlabel(&#39;Time (discrete)&#39;) ylabel(&#39;Time Evolution of Y&#39;) title([{&#39;Logisitc Map&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) subplot(2,1,2) % Create a graph the return plot set(gcf,&#39;Color&#39;,&#39;white&#39;); plot(Y(1:length(Y)-1),Y(2:length(Y)),&#39;.k&#39;); xlabel(&#39;Y(t)&#39;) ylabel(&#39;Y(t+1)&#39;) title([{&#39;Return Plot&#39;},{[&#39;Y_0 = &#39; num2str(Y0) &#39;, r = &#39; num2str(r)]}]) axis square Solution Logistic Map - Matlab -->"],
["mathematics-of-change-ii.html", "B Mathematics of Change II", " B Mathematics of Change II Solutions to assignments in section ?? Time-varying parameters Predator-prey dynamics "],
["time-varying-parameters.html", "B.1 Time-varying parameters", " B.1 Time-varying parameters Solutions in a spreadsheet Van Geert, including jumps and stages. B.1.1 Solutions in R The growth model by Van Geert (1991) Different values for r: library(plyr) # Parameters rs &lt;- c(1.2, 2.2, 2.5, 2.7, 2.9, 3) # Plot op &lt;- par(mfrow=c(1,2)) l_ply(rs,function(r){plot(growth.ac(r = r, Y0 = 0.01, type = &quot;vanGeert&quot;), ylim = c(0,1.4), ylab = &quot;L(t)&quot;, main = paste(&quot;r =&quot;,r))}) par(op) Different values for \\(k\\) reveal that the dispersion of values (variance) increases if the carrying capacity increases. This occurs because we are dealing with nonlinear changes to the values of \\(Y\\) and if larger values of \\(Y\\) are allowed by a hihger \\(k\\), these values will be amplified once they occur. # Parameters ks &lt;- c(0.5, 0.75, 1, 1.5) # Plot op &lt;- par(mfrow=c(1,2)) l_ply(ks,function(k){plot(growth.ac(r = 2.9, k = k, Y0 = 0.01, type = &quot;vanGeert&quot;), ylim = c(0, 2), ylab = &quot;L(t)&quot;, main = paste(&quot;k =&quot;,k))}) par(op) Stages and Jumps growth.ac.cond &lt;- function(Y0 = 0.01, r = 0.1, k = 2, cond = cbind.data.frame(Y = 0.2, par = &quot;r&quot;, val = 2), N = 100){ # Create a vector Y of length N, which has value Y0 at Y[1] Y &lt;- c(Y0, rep(NA, N-1)) # Iterate N steps of the difference equation with values passed for Y0, k and r. cnt &lt;- 1 for(t in seq_along(Y)){ # Check if the current value of Y is greater than the threshold for the current conditional rule in cond if(Y[t] &gt; cond$Y[cnt]){ # If the threshold is surpassed, change the parameter settings by evaluating: cond$par = cond$val eval(parse(text = paste(cond$par[cnt], &quot;=&quot;, cond$val[cnt]))) # Update the counter if there is another conditional rule in cond if(cnt &lt; nrow(cond)){cnt &lt;- cnt + 1} } # Van Geert growth model Y[[t+1]] &lt;- Y[t] * (1 + r - r * Y[t] / k) } return(ts(Y)) } # Plot with the default settings (same as first step in the assignment) xyplot(growth.ac.cond()) The ‘trick’ used here is to define the function such that it can take a set of conditional rules and apply them sequentially during the iterations. The conditiona rule is passed as a data.frame, but one could also use a list object. (cond &lt;- cbind.data.frame(Y = c(0.2, 0.6), par = c(&quot;r&quot;, &quot;r&quot;), val = c(0.5, 0.1))) Y par val 1 0.2 r 0.5 2 0.6 r 0.1 xyplot(growth.ac.cond(cond=cond)) Or, combine a change of r and a change of k (cond &lt;- cbind.data.frame(Y = c(0.2, 1.99), par = c(&quot;r&quot;, &quot;k&quot;), val = c(0.5, 3))) Y par val 1 0.20 r 0.5 2 1.99 k 3.0 xyplot(growth.ac.cond(cond=cond)) # A fantasy growth process (cond &lt;- cbind.data.frame(Y = c(0.1, 1.99, 1.999, 2.5, 2.9), par = c(&quot;r&quot;, &quot;k&quot;, &quot;r&quot;, &quot;r&quot;,&quot;k&quot;), val = c(0.3, 3, 0.9, 0.1, 1.3))) Y par val 1 0.100 r 0.3 2 1.990 k 3.0 3 1.999 r 0.9 4 2.500 r 0.1 5 2.900 k 1.3 xyplot(growth.ac.cond(cond=cond)) Connected Growers Somewhat more realstic would be to model a change of r as dependent on the values of another process. The proper ‘dynamical’ way to do this would be to define a coupled system of difference or differential equations in which the interaction dynamics regulate growth. An example is the predator-prey system discussed in the next assignment. Using the ‘conditional’ rules on a number of seperate processes will ‘work’ as a model, but it isn’t exactly what is meant by interaction dynamics, or multiplicative interactions. Basically, these processes will be independent and non-interacting. The conditional rules that change the parameters are ‘given’. # Generate 3 timeseries Y1 &lt;- growth.ac(k = 2, r =.2, type = &quot;vanGeert&quot;) # Y2 and Y3 start at r = 0.001 Y3 &lt;- Y2 &lt;- growth.ac(k = 2, r = 0.001, type = &quot;vanGeert&quot;) # Y2 and Y3 start when k is approached c1 &lt;- 1.6 c2 &lt;- 2.2 Y2[Y1 &gt; c1] &lt;- growth.ac(r = .3, k = 3, type = &quot;vanGeert&quot;, N = sum(Y1 &gt; c1)) Y3[Y2 &gt; c2] &lt;- growth.ac(r = .5, k = 4, type = &quot;vanGeert&quot;, N = sum(Y2 &gt; c2)) # Make a nice plot ts.plot(Y1, Y2, Y3, gpars = list(xlab = &quot;time (a.u.)&quot;, ylab = expression(Y(t)), main = expression(paste(&quot;&#39;Connected&#39; Growers &quot;,Y[t+1]==Y[t]*(1 + r - r*Y[t]))), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;) ) ) legend(1, 3.8, c(&quot;Y1(0): r = .2&quot;, paste0(&quot;Y2(&quot;,which(Y1 &gt; c1)[1],&quot;): r = .3&quot;), paste0(&quot;Y3(&quot;,which(Y2 &gt; c2)[1],&quot;): r = .5&quot;)), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;), merge = TRUE) "],
["ppdsol.html", "B.2 Predator-prey dynamics", " B.2 Predator-prey dynamics | jump to question | Iterating 2D Maps and Flows In order to ‘solve’ a differential equation for time using a method of numerical integration, one could code it like in the spreadsheet assignment. For R and Matlab there are so-called solvers available, functions that will do the integration for you. Look at the Examples in package deSolve. Solutions in a spreadsheet Predator-Prey Dynamics B.2.1 Solutions in R Euler’s method and more… The result of applying a method of numerical integration is called a numerical solution of the differential equation. The analytical solution is the equation which will give you a value of \\(Y\\) for any point in time, given an initial value \\(Y_0\\). Systems which have an analytical solution can be used to test the accuracy of numerical solutions. Remember that the analytical solution for the logistic equation is: \\[\\begin{equation} \\frac{K}{1 + \\left(\\frac{K}{Y_0 - 1}\\right) * e^{-r*t} } \\tag{B.1} \\end{equation}\\] We have the function growth.ac() and could easily adapt all the functions to use Euler’s method. Below is a comparison of the analytic solution with Euler’s method. # Parameter settings d &lt;- 1 N &lt;- 100 r &lt;- .1 k &lt;- 1 Y0 &lt;- 0.01 Y &lt;- as.numeric(c(Y0, rep(NA,N-1))) # Numerical integration of the logistic differential equation Y.euler1 &lt;- ts( sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- (r * Y[t] * (k - Y[t])) * d + Y[t] )) Y.euler2 &lt;- ts( sapply(seq_along(Y), function(t) Y[[t+1]] &lt;&lt;- (r * Y[t] * (k - Y[t])) * (d+.1) + Y[t] )) ## analytical solution Y.analytic &lt;- ts( k / (1 + (k / Y0 - 1) * exp(-r*(time(Y.euler1)))) ) ts.plot(Y.analytic, Y.euler1, Y.euler2, gpars = list(xlab = &quot;time (a.u.)&quot;, ylab = expression(Y(t)), main = expression(paste(&quot;Analytic vs. Numerical:&quot;,Y[t+1]==Y[t]*(1 + r - r*Y[t]))), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;) ) ) legend(50, 0.4, c(&quot;Analytic&quot;, &quot;Euler: delta = 1.0&quot;, &quot;Euler: delta = 1.1&quot;), lwd = rep(2,3), lty = c(1:3), col = c(&quot;darkred&quot;,&quot;darkblue&quot;,&quot;darkgreen&quot;), merge = TRUE) Numerical integration The Euler setup: \\[\\begin{align} R_{t+1} &amp;= f_R(R_t,Ft) * \\Delta + R_t \\\\ F_{t+1} &amp;= f_F(R_t,F_t) * \\Delta + F_t \\end{align}\\] With the equations: \\[\\begin{align} R_{t+1} &amp;= (a-b*F_t)*R_t * \\Delta + R_t \\\\ \\\\ F_{t+1} &amp;= (c*R_t-d)*F_t * \\Delta + F_t \\end{align}\\] # Parameters N &lt;- 1000 a &lt;- d &lt;- 1 b &lt;- c &lt;- 2 R0 &lt;- F0 &lt;- 0.1 R &lt;- as.numeric(c(R0, rep(NA,N-1))) F &lt;- as.numeric(c(F0, rep(NA,N-1))) # Time constant delta &lt;- 0.01 # Numerical integration of the logistic differential equation l_ply(seq_along(R), function(t){ R[[t+1]] &lt;&lt;- (a - b * F[t]) * R[t] * delta + R[t] F[[t+1]] &lt;&lt;- (c * R[t] - d) * F[t] * delta + F[t] }) # Note different behaviour when ts() is applied xyplot(cbind(ts(R),ts(F))) xyplot(R ~ F, pch = 16) -->"],
["btasol.html", "C Basic Timeseries Analysis ", " C Basic Timeseries Analysis "],
["nonlinear-growth-curves-in-spss.html", "C.1 Nonlinear Growth curves in SPSS", " C.1 Nonlinear Growth curves in SPSS | Jump to question | The solutions are provided as an SPSS syntax file file. Or copy the block below: GRAPH /LINE(SIMPLE)=VALUE(Yt) BY Time. * NonLinear Regression. MODEL PROGRAM Yzero=0.01 r=0.01 K=0.01. COMPUTE PRED_=K*Yzero/(Yzero + (K-Yzero) * EXP(-1*(r * K * Time))). NLR Yt /PRED PRED_ /SAVE PRED /CRITERIA SSCONVERGENCE 1E-8 PCON 1E-8. GRAPH /LINE(MULTIPLE)=VALUE(Yt PRED_) BY Time. COMPUTE T1=Yt * Time. COMPUTE T2=Yt * (Time ** 2). COMPUTE T3=Yt * (Time ** 3). COMPUTE T4=Yt * (Time ** 4). EXECUTE. REGRESSION /MISSING LISTWISE /STATISTICS COEFF OUTS R ANOVA /CRITERIA=PIN(.05) POUT(.10) /NOORIGIN /DEPENDENT Yt /METHOD=ENTER T1 T2 T3 T4 /SAVE PRED. GRAPH /LINE(MULTIPLE)=VALUE(Yt PRED_ PRE_1) BY Time. The point here is that the polynomial regression appoach is “just” curve fitting … adding components until a nice fit is found … but what does component \\(Y_t^4\\) represent? A quartic subprocess? Fitting the solution of the the logistic function will give us parameters we can interpret unambiguoulsy: Carrying capacity, growth rate, starting value. "],
["pacfsol.html", "C.2 Correlation functions and AR-MA models", " C.2 Correlation functions and AR-MA models | Jump to question | The solutions are provided as an SPSS syntax file file. Or copy the block below: DESCRIPTIVES VARIABLES=TS_1 TS_2 TS_3 /STATISTICS=MEAN STDDEV MIN MAX . *Sequence Charts . TSPLOT VARIABLES= TS_1 /NOLOG /FORMAT NOFILL REFERENCE. TSPLOT VARIABLES= TS_2 /NOLOG /FORMAT NOFILL REFERENCE. TSPLOT VARIABLES= TS_3 /NOLOG /FORMAT NOFILL REFERENCE. *ACF and PCF. ACF VARIABLES= TS_1 TS_2 TS_3 /NOLOG /MXAUTO 30 /SERROR=IND /PACF. * ARIMA with p=5 and q=1. TSET PRINT=DEFAULT CIN=95 NEWVAR=ALL . PREDICT THRU END. ARIMA TS_2 /MODEL=( 5 0 1)CONSTANT /MXITER= 10 /PAREPS= .001 /SSQPCT= .001 /FORECAST= EXACT . * ARIMA with p=2 and q=1. TSET PRINT=DEFAULT CIN=95 NEWVAR=ALL . PREDICT THRU END. ARIMA TS_2 /MODEL=( 2 0 1)CONSTANT /MXITER= 10 /PAREPS= .001 /SSQPCT= .001 /FORECAST= EXACT . *Plot Fit. GRAPH /LINE(MULTIPLE)=MEAN(TS_2) MEAN(FIT_2) MEAN(LCL_2) MEAN(UCL_2) BY TIME /MISSING=LISTWISE . *Return plots. COMPUTE TS_1_lag1 = LAG(TS_1) . COMPUTE TS_2_lag1 = LAG(TS_2) . COMPUTE TS_3_lag1 = LAG(TS_3) . EXECUTE . IGRAPH /VIEWNAME=&#39;Scatterplot&#39; /X1 = VAR(TS_1_lag1) TYPE = SCALE /Y = VAR(TS_1) TYPE = SCALE /COORDINATE = VERTICAL /X1LENGTH=3.0 /YLENGTH=3.0 /X2LENGTH=3.0 /CHARTLOOK=&#39;NONE&#39; /SCATTER COINCIDENT = NONE. EXE. IGRAPH /VIEWNAME=&#39;Scatterplot&#39; /X1 = VAR(TS_2_lag1) TYPE = SCALE /Y = VAR(TS_2) TYPE = SCALE /COORDINATE = VERTICAL /X1LENGTH=3.0 /YLENGTH=3.0 /X2LENGTH=3.0 /CHARTLOOK=&#39;NONE&#39; /SCATTER COINCIDENT = NONE. EXE. IGRAPH /VIEWNAME=&#39;Scatterplot&#39; /X1 = VAR(TS_3_lag1) TYPE = SCALE /Y = VAR(TS_3) TYPE = SCALE /COORDINATE = VERTICAL /X1LENGTH=3.0 /YLENGTH=3.0 /X2LENGTH=3.0 /CHARTLOOK=&#39;NONE&#39; /SCATTER COINCIDENT = NONE. EXE. Were you surprised finding out Timeseries 3 is the logisitc map in the chaotic regime? It ruly ‘looks’ random (according to PACF). "],
["using-r-to-fit-the-solutions.html", "C.3 Using R to fit the solutions", " C.3 Using R to fit the solutions There are several packages that can perform nonlinear regression analysis, the function most resembling the approach used by SPSS is nls in the default stats package. The easiest way to do this is to first define your function (i.e., the solution) and then fit it using starting values for the parameters. library(rio) df &lt;- import(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/assignmentData/BasicTSA_nonlinreg/GrowthRegression.sav&quot;, setclass = &quot;tbl_df&quot;) # Logistic growth # Same as SPSS syntax: PRED_=K*Yzero/(Yzero + (K-Yzero) * EXP(-1*(r * K * Time))). log.eq &lt;- function(Yzero, r, K, Time) { K*Yzero/(Yzero + (K-Yzero) * exp(-1*(r * K * Time))) } There is one drawback and you can read about in the help pages: Warning Do not use nls on artificial “zero-residual” data. This means, “do not use it on data generated by a deterministic model which has no residual error”, which is exactly what the timeseries in this assignment is, it is the output of the quadratic map in the chaotic regime. So, this will give an error: # Fit this function ... gives an error # The list after &#39;start&#39; provides the initial values m.log &lt;- nls(Yt ~ log.eq(Yzero, r, K, Time), data = df, start = list(Yzero=.01, r=.01, K=1), trace = T) It is possible to fit these ideal data using package minpack.lm, which contains function nlsM. library(minpack.lm) m.log &lt;- nlsLM(Yt ~ log.eq(Yzero, r, K, Time), data = df, start = list(Yzero = .01, r=.01, K=0.1)) summary(m.log) Formula: Yt ~ log.eq(Yzero, r, K, Time) Parameters: Estimate Std. Error t value Pr(&gt;|t|) Yzero 7.055e-03 8.983e-05 78.53 &lt;2e-16 *** r 1.491e-01 4.170e-04 357.59 &lt;2e-16 *** K 1.002e+00 4.376e-04 2289.42 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.002865 on 97 degrees of freedom Number of iterations to convergence: 13 Achieved convergence tolerance: 1.49e-08 In order to look at the model prediction, we use predict() which is defined for almost all modelfitting functions in R Ypred &lt;- predict(m.log) plot(ts(df$Yt), col=&quot;gray40&quot;, lwd=5, ylab = (&quot;Yt | Ypred&quot;)) lines(Ypred, col=&quot;gray80&quot;, lwd=2, lty=2) Then we do a polynomial regression using lm: # Mimic the SPSS syntax attach(df) df$T1 &lt;- Yt * Time df$T2 &lt;- Yt * (Time^2) df$T3 &lt;- Yt * (Time^3) df$T4 &lt;- Yt * (Time^4) detach(df) m.poly &lt;- lm(Yt ~ T1 + T2 + T3 + T4, data=df) summary(m.poly) Call: lm(formula = Yt ~ T1 + T2 + T3 + T4, data = df) Residuals: Min 1Q Median 3Q Max -0.0117491 -0.0046800 -0.0000683 0.0045719 0.0112732 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.113e-02 1.258e-03 16.80 &lt;2e-16 *** T1 6.366e-02 7.169e-04 88.80 &lt;2e-16 *** T2 -1.497e-03 3.100e-05 -48.28 &lt;2e-16 *** T3 1.510e-05 4.425e-07 34.12 &lt;2e-16 *** T4 -5.529e-08 2.055e-09 -26.90 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.005506 on 95 degrees of freedom Multiple R-squared: 0.9998, Adjusted R-squared: 0.9998 F-statistic: 1.264e+05 on 4 and 95 DF, p-value: &lt; 2.2e-16 Then, predict and plot! Ypoly &lt;- predict(m.poly) plot(ts(Ypoly), col=&quot;blue1&quot;, lwd=2, ylab = (&quot;Ypoly (blue) | Ypred (red)&quot;)) lines(Ypred, col=&quot;red1&quot;, lwd=2) SPSS computes an \\(r^2\\) value for nonlinear regression models, which doesn’t make a lot of sense if you think about it. Here we van just compare the residual errors: Polynomial regression: \\(0.005506\\) Analytic solution: \\(0.002865\\)&quot; Slightly less residual error for the analytic solution, using less parameters to fit the model (3 vs. 5). More important:, the paramters of the analytic solution have a direct interpretation in terms of growth processes. "],
["hrvsol.html", "C.4 Heartbeat dynamics", " C.4 Heartbeat dynamics | jump to assignment | library(rio) TS1 &lt;- rio::import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/RelativeRoughness/TS1.xlsx&quot;, col_names=FALSE) TS2 &lt;- rio::import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/RelativeRoughness/TS2.xlsx&quot;, col_names=FALSE) TS3 &lt;- rio::import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/RelativeRoughness/TS3.xlsx&quot;, col_names=FALSE) The Excel files did not have any column names, so let’s create them in the data.frame colnames(TS1) &lt;- &quot;TS1&quot; colnames(TS2) &lt;- &quot;TS2&quot; colnames(TS3) &lt;- &quot;TS3&quot; # Create a function for RR RR &lt;- function(ts){ # lag.max = n gives autocovariance of lags 0 ... n, VAR &lt;- acf(ts, lag.max = 1, type = &#39;covariance&#39;, plot=FALSE) # RR formula RelR &lt;- 2*(1-VAR$acf[2] / VAR$acf[1]) # Add some attributes to the output attributes(RelR) &lt;- list(localAutoCoVariance = VAR$acf[2], globalAutoCoVariance = VAR$acf[1]) return(RelR) } # Look at the results for(ts in list(TS1,TS2,TS3)){ relR &lt;- RR(ts[,1]) cat(paste0(colnames(ts),&quot;: RR = &quot;,round(relR,digits=3), &quot; = 2*(1-&quot;, round(attributes(relR)$localAutoCoVariance, digits = 4),&quot;/&quot;, round(attributes(relR)$globalAutoCoVariance,digits = 4),&quot;)\\n&quot;)) } TS1: RR = 0.485 = 2*(1-0.0016/0.0021) TS2: RR = 0.118 = 2*(1-0.0018/0.0019) TS3: RR = 2.052 = 2*(1--1e-04/0.002) Use Figure ?? to lookup which value of \\(RR\\) corresponds to which type of noise: TS1: Pink noise TS2: Brownian noise TS3: White noise C.4.1 Randomise To randomize the data you may use the function sample (which is easier than randperm) library(pracma) # randperm() TS1Random &lt;- TS1$TS1[randperm(length(TS1$TS1))] # sample() TS1Random &lt;- sample(TS1$TS1, length(TS1$TS1)) plot.ts(TS1Random) lines(ts(TS1$TS1),col=&quot;red3&quot;) If you repeat this for TS2 and TS3 and compute the Relative Roughness of each randomized time series, the outcomes should be around 2, white noise! This makes sense, you destroyed all the correlations in the data by removing the temporal order with which values were observed. C.4.2 Integrate Normalize the white noise time series TS3Norm &lt;- scale(TS3$TS3) Now integrate it, which just means, ‘take the cumulative sum’. TS3Int &lt;- cumsum(TS3Norm) plot.ts(TS3Int) lines(ts(TS3Norm),col=&quot;red3&quot;) If you compute the Relative Roughness of the integrated time series, the outcome should be close to 0, Brownian noise. RR(TS3Int) [1] 0.02783704 attr(,&quot;localAutoCoVariance&quot;) [1] 35.69734 attr(,&quot;globalAutoCoVariance&quot;) [1] 36.2012 -->"],
["fda1sol.html", "D Fluctuation and Disperion analyses I ", " D Fluctuation and Disperion analyses I "],
["psdsol.html", "D.1 Assignment: The Spectral Slope", " D.1 Assignment: The Spectral Slope | jump to assignment | First, load the data and source the function library. D.1.1 Example of using --ply functions Let’s try to use as few commands as possible to analyse all three timeseries. The easiest way to do this is to use the so-called apply family of functions. These functions pass the contents of a list object to a function. Suppose we need to calculate the means of column variables in 40 different SPSS .sav files stored in the folder DAT. With the rio package loaded we can execute the following commands: data &lt;- lapply(dir(&quot;/DAT/&quot;,pattern=&quot;.sav$&quot;),import) out &lt;- sapply(data,colMeans) The first command applies import to all files with a .sav extension found in the folder /DAT. It creates a dataframe for each file which are all stored as elements of the list object data. The second line applies the function colMeans to each element of data and puts the combined results in a matrix with the dataset ID as columns (1-40), dataset variables as rows and the calculated column means as cells. R comes with several apply functions installed, but an easier interface is provided by package plyr. When plyr is loaded you can use functions of the type XYply where X denotes the first letter of the input structure and Y the ouput structure: l for list, d for 'data.frame, a for array. So, laply() expects a listobject as input and will try to create an array as outout. There is also a special symbol for Y, the underscore _ if no output is expected, e.g. when plotting, l_ply. D.1.2 Data preparation Let’s prepare these series for spectral analysis. library(plyr) TSlist &lt;- list(TS1=TS1$TS1,TS2=TS2$TS2,TS3=TS3$TS3) # Plot raw l_ply(TSlist, plot.ts) # Normalise TSlist.n &lt;- llply(TSlist,scale) # Plot normalised l_ply(TSlist.n, plot.ts) # Detrend TSlist.nd &lt;- llply(TSlist.n, detrend) # Plot normalised, detrended l_ply(TSlist.nd, plot.ts) D.1.3 Time-series length Another preparation concerns checking wether the length of the series is a power of 2 (or 10). This is necessary for the Fourier transfrom to run smoothly. The code below uses log2 and nextpow2 to figure out whether the data length is ok. What is different from previous uses of the XYply functions is that we now customise the function we want to execute. The input is still a list object, each element of the list is passed as a variable ts to a so-called anonymous function, a function just denoted as function(ts). The function returns a data.frame with columns pow2, the current power of 2 and nextpow2 (a function of pracma) the next power of 2. The XYply functions will add an .id variable to the output if the input is a list with named fields. Although we create 3 data frames of one row, the d in ldply indicates these frames have to be merged if possible. ldply(TSlist.nd, function(ts) data.frame(pow2 = log2(length(ts)), nextpow2 = nextpow2(length(ts)))) .id pow2 nextpow2 1 TS1 11 11 2 TS2 11 11 3 TS3 11 11 In this case we don’t have to take any action, \\(2048\\) is a power of 2. Actions that could be taken are: removing datapoints from the front of the series, or, padding the series with zeroes. D.1.4 The fd.psd function The function created for spectral analysis fd.psd() will perform normalisation and detrending by default. It also returns information about the power spectrum and log-log fit. It’s good to know about the default settings of a function, and the return values. The best place to look for them is usually the help documentation, or the vignettes that come with a package. If you select a function in Rstudio and press F1 you’ll get the help page, If you press F2 can have a look at the code (if it is exported), or, you can call the function without parentheses fd.psd and the code will be printed to the Console. You can also hover the cursor after you typed the name of the function to reveal the arguments and defaults: Figure D.1: Get default values of function arguments. Another way to get this info is to use the function formals() formals(fd.psd) $y $fs NULL $normalize [1] TRUE $dtrend [1] TRUE $plot [1] FALSE Now we know this function has arguments normalize and dtrend set to TRUE, and plot set to FALSE. We could feed the fuction the raw data, or feed it our normalised, detrended, data and change the defaults. In the XYply functions, you can just add function arguments after the function name. # Analyse outPSD &lt;- llply(TSlist.nd, fd.psd, normalize = FALSE, dtrend = FALSE, plot=TRUE) fd.psd: Sample rate was set to 1. fd.psd: Sample rate was set to 1. fd.psd: Sample rate was set to 1. -->"],
["fda1so2.html", "E Fluctuation and Disperion analyses II", " E Fluctuation and Disperion analyses II There were no assignments for this Lecture. "],
["RQAsol.html", "F Phase Space Reconstruction and Recurrence Quantification Analysis (RQA) ", " F Phase Space Reconstruction and Recurrence Quantification Analysis (RQA) "],
["phase-space-reconstruction-of-the-lorenz-attractor.html", "Phase Space Reconstruction of the Lorenz Attractor", " Phase Space Reconstruction of the Lorenz Attractor Here we load some libraries that are not strictly necessary, but which do provide some nice interactive tools. library(devtools) library(fractal) library(rgl) library(plot3D) library(crqa) Loading required package: Matrix Attaching package: &#39;Matrix&#39; The following objects are masked from &#39;package:pracma&#39;: expm, lu, tril, triu Loading required package: tseriesChaos Loading required package: deSolve Attaching package: &#39;deSolve&#39; The following object is masked from &#39;package:pracma&#39;: rk4 Loading required package: fields Loading required package: spam Loading required package: grid Spam version 1.4-0 (2016-08-29) is loaded. Type &#39;help( Spam)&#39; or &#39;demo( spam)&#39; for a short introduction and overview of this package. Help for individual functions is also obtained by adding the suffix &#39;.spam&#39; to the function name, e.g. &#39;help( chol.spam)&#39;. Attaching package: &#39;spam&#39; The following objects are masked from &#39;package:base&#39;: backsolve, forwardsolve Loading required package: maps Attaching package: &#39;maps&#39; The following object is masked from &#39;package:plyr&#39;: ozone library(dygraphs) source_url(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/functionLib/nlRtsa_SOURCE.R&quot;) SHA-1 hash of file is 6560a402346f18ea86f1047e1c91d052a6e3cd6d Instead of rgl::plot3d we use plot3D::scatter3D to display the Lorenz attractor, because the 3D interactive plot doesn’t run inside this webbook. N &lt;- 3000 scatter3D(lorenz[1:N, 1], lorenz[1:N,2], lorenz[1:N,3], pch=&quot;.&quot;, col = &quot;black&quot;, colkey = FALSE, type = &quot;l&quot;) The three coupled equations of the Lorenz system constitute the three dimensions (X,Y and Z) of the state space of the system. lxyz &lt;- data.frame(t=1:N, lorenz[1:N, ]) dygraph(lxyz, main = &quot;Lorenz System - Chaotic Regime&quot;) %&gt;% dyHighlight(highlightCircleSize = 5, hideOnMouseOut = FALSE) %&gt;% dyOptions(colors = RColorBrewer::brewer.pal(3, &quot;Set2&quot;), drawGrid = FALSE) %&gt;% dyLegend(showZeroValues = TRUE) "],
["embedding-lag.html", "F.1 Embedding Lag", " F.1 Embedding Lag Determine the embedding lag for optimal reconstruction. Use average mutual information as the criterion for selecting a delay. In the Shiny widget below, you can explore other settings. Mutual information generally gives the best results. lagX &lt;- timeLag(lxyz$X, method = &quot;mutual&quot;, plot.data = TRUE) "],
["false-nearest-neighbours.html", "F.2 False Nearest Neighbours", " F.2 False Nearest Neighbours Determine how many points in the state space turn out to be neigbours if embedding dimension \\(n\\) is added to the state space \\(X(t), X(t + \\tau), \\ldots, X(t + n*\\tau)\\). (fnnX &lt;- FNN(lxyz$X, tlag = lagX)) False Nearest Neighbors for lxyz$X ---------------------------------- Series points : 3000 Embedding dimension(s) : 1 2 3 4 5 Time lag : 17 Oribital lag : 1 Neighbor tolerance (rtol) : 10 Attractor tolerance (atol) : 2 Test results (%): E=1 E=2 E=3 E=4 E=5 rtol 97.84 5.97 0 0 0 atol 1.42 0.00 0 0 0 combined 97.84 5.97 0 0 0 -->"],
["recurrence-quantification-analysis.html", "G Recurrence Quantification Analysis", " G Recurrence Quantification Analysis "],
["assignment-auto-recurrence-quantification-analysis.html", "H Assignment: (auto-)Recurrence Quantification Analysis", " H Assignment: (auto-)Recurrence Quantification Analysis NOTE: Package crqa() was designed to run categorical Cross-Recurrence Quantification Analysis (see Coco &amp; Dale (2014) and for R code see appendices in Coco &amp; Dale (2013)). We can trick it to run auto-RQA by providing the same timeseries for ts1 and ts2 and setting the parameter side to either &quot;upper&quot; or &quot;lower&quot; Perform an RQA on the reconstructed state space of the Lorenz system. You’ll need a radius (also called: threshold) in order to decide which points are close together (recurrent). crqa provides a function which will automatically select the best parametersettings: optimizeParam() Best way to ensure you are using the same parameters in each function is to create some lists with parametersettings (check the crqa manual to figure out what these parameters mean): # General settings for `crqa()` par0 &lt;- list(rescale = 1, normalize = 0, mindiagline = 2, minvertline = 2, tw = 0, whiteline = FALSE, recpt = FALSE, side = &quot;lower&quot;, checkl = list(do = FALSE, thrshd = 3, datatype = &quot;categorical&quot;,pad = TRUE) ) # Settings for `optimizeParam()` par &lt;- list(lgM = 20, steps = seq(1, 6, 1), radiusspan = 100, radiussample = 40, normalize = par0$normalize, rescale = par0$rescale, mindiagline = par0$mindiagline, minvertline = par0$minvertline, tw = par0$tw, whiteline = par0$whiteline, recpt = par0$recpt, fnnpercent = 10, typeami = &quot;mindip&quot;) Get the optimal parameters using a radius which will give us 2%-5% recurrent points. (ans &lt;- optimizeParam(ts1 = lxyz$X, ts2 = lxyz$X, par = par, min.rec = 2, max.rec = 5)) $radius [1] 17.2439 $emddim [1] 2 $delay [1] 18 Run the RQA analysis using the same settings with which the parameters were found. crqaOutput &lt;- crqa(ts1 = lxyz$X, ts2 = lxyz$X, delay = ans$delay, embed = ans$emddim, radius = ans$radius, normalize = par0$normalize, rescale = par0$rescale, mindiagline = par0$mindiagline, minvertline = par0$minvertline, tw = par0$tw, whiteline = par0$whiteline, recpt = par0$recpt, side = par0$side, checkl = par0$checkl ) The output of crqa is a list with recurrence measures, the last entry is the recurrence plot. It is represented as a so-called sparse-matrix. This representation severely decreases the amount of memory occupied by the recurrence matrix. It is basically a list of indices of cells that contain a \\(1\\). The \\(0\\) do not need to be stored. In order to plot this matrix you could use image(), but this does not produce the recurrence plot as they are usually displayed, the y-axis needs to be flipped. We created a function which will take as input the list output of crqa, together with lattice::levelplot the recurrence matrix can be created. If you have loaded (or sourced) the nlRtsa package you can call plotRP.crqa(crqaOutput). plotRP.crqa(crqaOutput) Loading required package: gridExtra Attaching package: &#39;gridExtra&#39; The following object is masked from &#39;package:dplyr&#39;: combine RP in crqa output is a Triangular Sparse Matrix, this implies auto-recurrence... Large RP with 8892324 elements... &gt;&gt; This could take some time to plot! "],
["CRQAsol.html", "I Categorical and Cross-RQA (CRQA)", " I Categorical and Cross-RQA (CRQA) "],
["cuspsol.html", "J The Cusp Catasrophe Model &amp; Warning Signs", " J The Cusp Catasrophe Model &amp; Warning Signs "],
["netssol.html", "K Complex Networks", " K Complex Networks "]
]
