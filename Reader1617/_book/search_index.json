[
["how-to.html", "How to … ", " How to … These assignments were designed to prepare you for “real world” modelling and data analysis problems. That is, after completing the assignments you should be able to decide whether the phenomenon you study could benefit from a complex systems approach and which type of analyses would be a good place to start. The models and techniques discussed here are not a definite collection of available techniques, this is really just the tip of the iceberg. General Guidelines Read the instructions carefully. Do not skip any of the steps. Do not copy-paste from the assignment text into a spreadsheet or syntax editor (except for text in code blocks). Study the solutions and lecture notes. Files on GitHub All the files (data, scripts, the files that generated this document) are in a repository on Github. Github keeps track of all the different versions of the files in a repository. If you want to download a file that is basically a text file (e.g. and R script), find a button named raw, then copy the text in your browser, or save as a text file. For non-text files, a download button will be present somewhere on the page. "],
["moc1ass.html", "2 Mathematics of Change I", " 2 Mathematics of Change I In this assignment you will build two (relatively) simple one-dimensional maps. We start with the Linear Map and then proceed to the slightly more complicated Logistic Map (aka Quadratic map). You can use your favourite spreadsheet software (e.g., Excel, Numbers, GoogleSheets). If you are experienced in R or Matlab you can try to code the models using the hints in section 2.3. Besure to check the solutions of the assigment which provide examples of different ways to visualize the time series in R "],
["the-linear-map.html", "2.1 The Linear Map", " 2.1 The Linear Map Equation (2.1) is the ordinary difference equation (ODE) discussed in the lecture (see lecture notes ??) is called the Linear Map: \\[\\begin{equation} Y_{t+1} = Y_{t=0} + r*Y_t \\tag{2.1} \\end{equation}\\] In these excersises you will simulate time series produced by the change process in equation @(eq:linmap) for different parameter settings of the growth-rate parameter \\(r\\) (the control parameter) and the initial conditions \\(Y_0\\). This is different from a statistical analysis in which parameters are estimated from a data set. The goal of the assignments is to get a feeling for what a dynamical model is, and how it is different from a linear statistical regression model like GLM. 2.1.1 The Linear Map in a Spreadsheet Before you begin, be sure to check the following settings: Open a Microsoft Excel worksheet, a Google sheet, or other spreadsheet. Check whether the spreadsheet uses a ‘decimal-comma’ (\\(0,05\\)) or ‘decimal-point’ (\\(0.05\\)) notation. The numbers given in the assignments of this course all use a ‘decimal-point’ notation. Check if the $ symbol fixes rows and columns when it used in a formula in your preferred spreadsheet program. This is the default setting in Microsoft Excel and Google. If you use one of those programs you are all set, otherwise you will have to replace the $ used in the assignments with the one used by your software. Type r in cell A5. This is the control parameter. It receives the value \\(1.08\\) in cellB5. Type \\(Y_0\\) in cell A6. This is the initial value. It receives the value \\(0.1\\) in cell B6. Use the output level (\\(Y_t\\)) of every step as the input to calculate the next level (\\(Y_{t+1}\\)). Rows in the spreadsheet will represent the values of the process at different moments in time. Put the initial value (\\(Y_0\\)) in cell A10. This cell marks time \\(t=0\\). To get it right, type: =$B$6. The = means that (in principle) there is a ‘calculation’ going on (a function is applied). The $ determines that column ($B) as well as the row ($6) keep the same value (i.e., constant) for each time step. Enter the Linear Map as a function in each cell. Type =$B$5*A10 in cell A11. This means that the value of cell A11 (i.e. \\(Y_{t=1}\\)) will be calculated by multiplying the value of cell B5 (parameter r) with the value of cell A10 (previous value, here: \\(Y_{t=0}\\)). If everything is all right, cell A11 now shows the value \\(0.108\\). Repeat this step for cell A12. Remember what it is you are doing! You are calculating \\(Y_{t=2}\\) now (i.e. the next step), which is determined by \\(Y_{t=1}\\) (i.e., the previous step) and the parameter r. Now repeat this simple iterative step for 100 further steps. Instead of typing everything over and over again, copy-paste the whole thing.Most spreadsheet programs will automatically adjust the formula by advancing each row or column number that aren’t fixed by $. Copy cell A12 all the way from A13 to A110 (keep the SHIFT button pressed to select all cells). You have just simulated a time series based on a theoretical change process! 2.1.2 Visualizing the time series Select cells A10 to A110 Create a line graph (Insert, 2D-line, Scatter). This will show you the graph. (There are other ways to do this, by the way, which work just as well.) You can play with the setting to make the best suitable view, like rescaling the axes. If you change the values in cells B5 and B6 you will see an immediate change in the graph. To study model behaviour, try the following growth parameters: \\(a = -1.08\\) \\(a = 1,08\\) \\(a = 1\\) \\(a = -1\\) Change the initial value \\(Y_0\\) in cell B6 to \\(10\\). Subsequently give the growth parameter in cell B5 the following values \\(0.95\\) and \\(-0.95\\). "],
["the-logistic-map-in-a-spreadsheet.html", "2.2 The Logistic Map in a spreadsheet", " 2.2 The Logistic Map in a spreadsheet The Logistic Map takes the following functional form: \\[\\begin{equation} Y_{t+1} = r*Y_t*(1-Y_t) \\tag{2.2} \\end{equation}\\] To get started, copy the spreadsheet from the previous assignment to a new sheet. The parameters are the same as for the Linear Map, there has to be an initial value \\(Y_{t=0}\\) (no longer explicit as a constant in equation (2.2)) and the control parameter \\(r\\). What will have to change is Start with the following values for control parameter \\(r\\): \\(r = 1.9\\) \\(Y_0 = 0.01\\) (in A6). Take good notice of what is constant (parameter \\(r\\)), so for which the $ must be used, and what must change on every iterative step (variable \\(Y_t\\)). 2.2.1 Visualizing the time series and explore its behaviour Create the time series graphs as for the Linear Map. To study the behavior of the Logistic Map you can start playing around with the values for the parameters and the initial values in cells B5 and B6. Be sure to try the following settings for \\(r\\): \\(r = 0.9\\) \\(r = 1.9\\) \\(r = 2.9\\) \\(r = 3.3\\) \\(r = 3.52\\) \\(r = 3.9\\) Set \\(r\\) at \\(4.0\\): Repeat the iterative process from A10 to A310 (300 steps) Now copy A10:A310 to B9:B309 (i.e., move it one cell to the right, and one cell up) Select both columns (A10 to B309!) and make a scatter-plot 2.2.2 The return plot The plot you just produced is a so called return plot, in which you have plotted \\(Y_{t+1}\\) against \\(Y_t\\). Can you explain the pattern you see (a ‘parabola’) by looking closely at the functional form of the Logistic Map? (hint: it’s also called Quadratic Map) Look at what happens in the return plot when you change the value of the parameter \\(r\\) (in A5). What do you expect the return plot of the Linear Map will look like? Try it! The meaning and use of this plot was discussed in the next session "],
["moc1R.html", "2.3 Using R or Matlab to do the exercises.", " 2.3 Using R or Matlab to do the exercises. The best (and easiest) way to simulate these simple models is to create a function which takes as input the parameters (\\(Y_0\\), \\(r\\)) and a variable indicating the length of the time series. For example for the Linear Map: # In R linearMap &lt;- function(Y0 = 0, r = 1, N = 100){ # Initialize Y as an NA vector of size N with as first entry Y0 Y &lt;- c(Y0, rep(NA,N-1)) for(i in 1:N){ Y[i+1] &lt;- # Implement the function here } return(Y) } # In Matlab function linearMap(Y0,r,N) # Implement the function here end Creating the time series graphs and the return plot should be easy if the function linearMap returns the time series. Both R and Matlab have a plot() function you can call.1 --> Both R and Matlab have specialized objects to represent timeseries, and functions and packages for timeseries analysis. They are especially convenient for plotting time and date information on the X-axis. See Solutions: Mathematics of Change I↩ "],
["moc2ass.html", "3 Mathematics of Change II", " 3 Mathematics of Change II In this assignment we will build a more sophisticated growth modeland look at its properties. The model will be the growth model by Van Geert (1991 etc.) as discussed in the book chapter you read. If your are experienced in R or Matlab you can try to code the models following the hints in section 2.3. The growth model by Van Geert (1991) The growth model by Van Geert has the following form: \\[\\begin{equation} L_{t+1} = L_t * (1 + r - r * \\frac{L_t}{K}) \\tag{3.1} \\end{equation}\\] Note the similarities to Equation (2.2), the (stylized) logistic map. "],
["the-growth-model-in-a-spreadsheet.html", "3.1 The growth model in a spreadsheet", " 3.1 The growth model in a spreadsheet Before you begin, be sure to check the following settings (same as first asignment): Open a Microsoft Excel worksheet or a Google sheet Check whether the spreadsheet uses a ‘decimal-comma’ (\\(0,05\\)) or ‘decimal-point’ (\\(0.05\\)) notation. The numbers given in the assignments of this course all use a ‘decimal-point’ notation. Check if the $ symbol fixes rows and columns when it used in a formula in your preferred spreadsheet program. This is the default setting in Microsoft Excel and Google Sheets. If you use one of those programs you are all set. To build it repeat some of the steps you performed in assignment 2 on a new worksheet. Define the appropriate constants (\\(r\\) in A5, \\(L_0\\) in A6) and prepare the necessary things you need for building an iterative process. In particular, add the other parameter that appears in Van Geert???s model: Type \\(K\\) in cell A7. This is the carrying capacity. It receives the value \\(1\\) in cell B7. Start with the following values: \\(r = 1.2\\) \\(L_0 = 0.01\\) Take good notice of what is constant (parameters \\(r\\) and \\(K\\)), for which the $ must be used, and what must change on every iterative step (variable \\(L_t\\)). Take about \\(100\\) steps. Create the graphs You can start playing with the values for the parameters and the initial values in cells B5, B6 and B7. To study this model???s behavior, be sure to try the following growth parameters: \\(r = 1.2\\) \\(r = 2.2\\) \\(r = 2.5\\) \\(r = 2.7\\) \\(r = 2.9\\) For the carrying capacity \\(K\\) (cell B7) you can try the following values: \\(K = 1.5\\) \\(K = 0.5\\). (Leave \\(r = 2.9\\). Mind the value on the vertical axis!) Changes in the values of \\(K\\) have an effect on the height of the graph. The pattern itself also changes a bit. Can you explain why this is so? "],
["conditional-growth-jumps-and-stages.html", "3.2 Conditional growth: Jumps and Stages", " 3.2 Conditional growth: Jumps and Stages Auto-conditional jumps Suppose we want to model that the growth rate \\(r\\) increases after a certain amount has been learned. In general, this is a very common phenomenon, for instance: when becoming proficient at a skill, growth (in proficiency) is at first slow, but then all of a sudden there can be a jump to the appropriate (and sustained) level of proficiency. Take the model you just built as a starting point with \\(r = 0.1\\) (B5) Type \\(0.5\\) in C5. This will be the new parameter value for \\(r\\). Build your new model in column B (leave the original in A). Suppose we want our parameter to change when a growth level of \\(0.2\\) is reached. We???ll need an IF statement which looks something like this: IF \\(L &gt; 0.2\\) then use the parameter value in C5, otherwise use the parameter value in B5. Excel has a built in IF function (may be ALS in Dutch). In the first cell in which calculations should start, press \\(=\\) and then from the formula list choose the IF function, or just type it. Try to figure out what you have to do. In the Logical_test box you should state something which expresses \\(L &gt; 0.2\\). The other fields tell Excel what to do when this statement is TRUE (then use parameter value in C5) or when it is FALSE (then use paramter value in B5). Note: the word value might be misleading; you can also input new statements. Make a graph in which the old and the new conditional models are represented by lines. Try changing the value of \\(r\\) in C5 into: \\(1, 2, 2.8, 2.9, 3\\). Auto-conditional stages Another conditional change we might want to explore is that when a certain growth level is reached the carrying capacity K increases, reflecting that new resources have become available to support further growth. Now we want \\(K\\) to change, so type \\(1\\) in B7, \\(2\\) in C7. Build your model in column C. Follow the same steps as above, but now make sure that when \\(L &gt; 0.99\\), \\(K\\) changes to the value in C7. Keep \\(r = 0.2\\) (B5). If all goes well you should see two stages when you create a graph of the timeseries in column C. Change \\(K\\) in C7 to other values. Try to also change the growth rate r after reaching \\(L &gt; 0.99\\) by referring to C5. Start with a value of \\(0.3\\) in C5. Set \\(K\\) in C7 to \\(2\\) again. Also try \\(1, 2.1, 2.5, 2.6, 3\\). Connected growers You can now easly model coupled growth processes, in which the values in one series serve as the trigger for for parameter changes in the other process. Try to recreate the Figure of the connected growers printed in the chapter by Van Geert. 3.2.0.1 Demonstrations of dynamic modeling using spreadsheets See the website by Paul Van Geert, scroll down to see models of: Learning and Teaching Behaviour Modification Connected Growers Interaction during Play "],
["iterating-2d-maps-and-flows.html", "3.3 Iterating 2D Maps and Flows", " 3.3 Iterating 2D Maps and Flows In this assignment we will look at a 2D coupled dynamical system: the Predator-Prey model (aka Lotka-Volterra equations). If your are experienced in R or Matlab you can try to code the models following the instructions at the end of this assignment. "],
["predator-prey-model.html", "3.4 Predator-prey model", " 3.4 Predator-prey model The dynamical system is given by the following set of first-order differential equations, one represents changes in a population of predators, (e.g., Foxes: \\(f_F(R_t,F_t)\\) ), the other represents changes in a population of prey, (e.g., Rabbits: \\(f_R(R_t,F_t)\\) ). \\[\\begin{align} \\frac{dR}{dt}&amp;=(a-b*F)*R \\\\ \\\\ \\frac{dF}{dt}&amp;=(c*R-d)*F \\tag{3.2} \\end{align}\\] This is not a difference equation but a differential equation, which means building this system is not as straightforward as was the case in the previous assignments. Simulation requires a numerical method to ‘solve’ this differential equation for time, which means we need a method to approach, or estimate continuous time in discrete time. Below you will receive a speed course in one of the simplest numerical procedures for integrating differential equations, the Euler method. 3.4.1 Euler Method A general differential equation is given by: \\[\\begin{equation} \\frac{dx}{dt} = f(x) \\tag{3.3} \\end{equation}\\] Read it as saying: “a change in \\(x\\) over a change in time is a function of \\(x\\) itself”. This can be approximated by considering the change to be over some constant, small time step \\(\\Delta\\): \\[\\begin{equation} \\frac{(x_{t+1} = x_t)}{\\Delta} = f(x_t) \\tag{3.4} \\end{equation}\\] After rearranging the terms a more familiar form reveals itself: \\[\\begin{align} x_{t+1} &amp;= x_t &amp;= f(x_t) * \\Delta \\\\ x_{t+1} &amp;= f(x_t) * \\Delta + x_t \\tag{3.5} \\end{align}\\] This looks like an ordinary iterative process, \\(\\Delta\\) the time constant determines the size of time step taken at every successive iteration. For a 2D system with variables R and F on would write: \\[\\begin{align} R_{t+1} &amp;= f_R(R_t,Ft) * \\Delta + R_t \\\\ F_{t+1} &amp;= f_F(R_t,F_t) * \\Delta + F_t \\tag{3.6} \\end{align}\\] 3.4.2 Coupled System in a spreadsheet Implement the model in a spreadsheet by substituting \\(f_R(R_t,Ft)\\) and \\(f_F(R_t,F_t)\\) by the differential equations for Foxes and Rabbits given above. Start with \\(a = d = 1\\) and \\(b = c = 2\\) and the initial conditions \\(R_0 = 0.1\\) and \\(F_0 = 0.1\\). Use a time constant of \\(0.01\\) and make at least \\(1000\\) iterations. Visualize the dynamics of the system by plotting: \\(F\\) against \\(R\\) (i.e., the state space) \\(R\\) and \\(F\\) against time (i.e., the timeseries) in one plot. Starting from the initial predator and prey population represented by the point \\((R, F) = (0.1, 0.1)\\), how do the populations evolve over time? Try to get a grip on the role of the time constant by increasing and decreasing it slightly (e.g. \\(\\Delta = 0.015\\)) for fixed parameter values. (You might have to add some more iterations to complete the plot). What happens to the plot? Hint: Remember that \\(\\Delta\\) is not a fundamental part of the dynamics, but that it is only introduced by the numerical integration (i.e., the approximation) of the differential equation. It should not change the dynamics of the system, but it has an effect nonetheless. | jump to solution | "],
["the-competetive-lottka-volterra-equations.html", "3.5 The Competetive Lottka-Volterra Equations", " 3.5 The Competetive Lottka-Volterra Equations The coupled predator-prey dynamics in the previous assignment are not a very realistic model of an actual ecological system. Both equations are exponential growth functions, but Rabbits for example, also have to eat! One way to increase realism is to consider coupled logistic growth by introducing a carrying capacity. Follow the link to the Wiki page and try to model the system! This is what interaction dynamics refers to, modeling mutual dependiencies using the if ... then conditional rules isn’t really about interaction, or coupling between processes. "],
["predator-prey-and-other-dynamics-as-agent-based-models.html", "3.6 Predator-Prey (and other) dynamics as Agent Based Models", " 3.6 Predator-Prey (and other) dynamics as Agent Based Models Agent-Based models are an expansion of the idea of “connected growers” that includes a spatial location of the things that is subject to change over time. Have a look at some of the NETlogo demo’s: Rabbits Weeds Grass Wolf Sheep Grass -->"],
["basic-timeseries-analysis.html", "4 Basic Timeseries Analysis", " 4 Basic Timeseries Analysis Most of the basic timeseries analyses can be performed in SPSS, because many of you will be familiar with the software we present the first assignments mainly as SPSS instructions, but you can go ahead an try your preferred environment for (statistical) computing. See the comments about using R and Matlab) "],
["time-series-analysis-in-spss-17-and-higher.html", "4.1 Time series analysis in SPSS (17 and higher)", " 4.1 Time series analysis in SPSS (17 and higher) 4.1.1 Nonlinear Growth curves in SPSS Open the file Growthregression.sav, it contains two variables: Time and Y(t). This is data from an iteration of the logistic growth differential equation you are familiar with by now, but let’s pretend it’s data from one subject measured on 100 occasions. Plot Y(t) against Time Recognize the shape? To get the growth parameter we’ll try to fit the solution of the logistic flow with SPSS nonlinear regression Select nonlinear… from the Analysis &gt;&gt; Regression menu. Here we can build the solution equation. We need three parameters: a. Yzero, the initial condition. b. K, the carrying capacity. c. r, the growth rate. Fill these in where it says parameters give all parameters a starting value of \\(0.01\\) Take a good look at the analytic solution of the (stilized) logistic flow: \\[ Y(t) = \\frac{K * Y_0}{Y_0 + \\left(K-Y_{0}\\right) * e^{(-K*r*t)} } \\] Tr to build this equation, the function fo \\(e\\) is called EXP in SPSS (Function Group &gt;&gt; Arithmetic) Group terms by using parentheses as shown in the equation. If you think you have built the model correctly, click on Save choose predicted values. Then paste your syntax and run it! Check the estimated parameter values. Check \\(R^2\\)!!! Plot a line graph of both the original data and the predicted values. (Smile) A polynomial fishing expedition: Create time-varying covariates of \\(Y(t)\\): COMPUTE T1=Yt * Time. COMPUTE T2=Yt * (Time ** 2). COMPUTE T3=Yt * (Time ** 3). COMPUTE T4=Yt * (Time ** 4). EXECUTE. Use these variables as predictors of \\(Y(t)\\) in a regular linear regression analysis. This is called a polynomial regression: Fitting combinations of curves of different shapes on the data. Before you run the analysis: Click Save Choose Predicted Values: Unstandardized Look at \\(R^2\\). This is also almost 1. Which model is better? Think about this: Based o the results o the linear regression what can yo tell about the growth rate, the carrying capacity or the initial condition? Create a line graph of \\(Y(t)\\), plot the predicted values of the nonlinear regression and the unstandardized predicted values of the linear polynomial regression against time in one figure. Now you can see that the shape is approximated by the polynomials, but it is not quite the same. Is this really a model of a growth process as we could encounter it in nature? | jump to solution | 4.1.2 Correlation functions and AR-MA models Download the file series.sav from blackboard. It contains three time series TS_1, TS_2 and TS_3. As a first step look at the mean and the standard deviation (Analyze &gt;&gt; Descriptives). Suppose these were time series from three subjects in an experiment, what would you conclude based on the means and SD’s? Let’s visualize these data. Go to Forecasting &gt;&gt; Time Series &gt;&gt; Sequence Charts. Check the box One chart per variable and move all the variables to Variables. Are they really the same? Let’s look at the ACF and PCF Go to Analyze &gt;&gt; Forecasting &gt;&gt; Autocorrelations. Enter all the variables and make sure both Autocorrelations (ACF) and Partial autocorrelations (PACF) boxes are checked. Click Options, and change the Maximum Number of Lags to 30. Use the table to characterize the time series: SHAPE INDICATED MODEL Exponential, decaying to zero Autoregressive model. Use the partial autocorrelation plot to identify the order of the autoregressive model Alternating positive and negative, decaying to zero Autoregressive model. Use the partial autocorrelation plot to help identify the order. One or more spikes, rest are essentially zero Moving average model, order identified by where plot becomes zero. Decay, starting after a few lags Mixed autoregressive and moving average model. All zero or close to zero Data is essentially random. High values at fixed intervals Include seasonal autoregressive term. No decay to zero Series is not stationary. You should have identified just one time series with autocorrelations: TS_2. Try to fit an ARIMA(p,0,q) model on this time series. Go to Analyze &gt;&gt; Forecasting &gt;&gt; Create Model, and at Method (Expert modeler) choose ARIMA. Look back at the PACF to identify which order (p) you need (last lag value at which the correlation is still significant). This lag value should go in the Autocorrelation p box. Start with a Moving Average q of one. The time series variable TS_2 is the Dependent. You can check the statistical significance of the parameters in the output under Statistics, by checking the box Parameter Estimates. This value for p is probably too high, because not all AR parameters are significant. Run ARIMA again and decrease the number of AR parameters by leaving out the non-significant ones. By default SPSS saves the predicted values and 95% confidence limits (check the data file). We can now check how well the prediction is: Go to Graphs &gt;&gt; Legacy Dialogs &gt;&gt; Line. Select Multiple and Summaries of Separate Variables. Now enter TS_2, Fit_X, LCL_X and UCL_X in Lines Represent. X should be the number of the last (best) model you fitted, probably 2. Enter TIME as the Category Axis. In the simulation part of this course we have learned a very simple way to explore the dynamics of a system: The return plot. The time series is plotted against itself shifted by 1 step in time. Create return plots (use a Scatterplot) for the three time series. Tip: You can easily create a t+1 version of the time series by using the LAG function in a COMPUTE statement. For instance: COMPUTE TS_1_lag1 = LAG(TS_1) Are your conclusions about the time series the same as in 3. after interpreting these return plots? | jump to solution | "],
["notes-on-tsa-in-r-and-matlab.html", "4.2 Notes on TSA in R and Matlab", " 4.2 Notes on TSA in R and Matlab If you use R the command below will install all the packages we will use during the entire course on you private computer. This might take too long on a university PC, just install the packages you need for an assignment each session. install.packages(c(&quot;devtools&quot;, &quot;rio&quot;, &quot;plyr&quot;, &quot;dplyr&quot;, &quot;tidyr&quot;, &quot;Matrix&quot;, &quot;ggplot2&quot;, &quot;lattice&quot;, &quot;latticeExtra&quot;, &quot;grid&quot;, &quot;gridExtra&quot;, &quot;rgl&quot;, &quot;fractal&quot;, &quot;nonlinearTseries&quot;, &quot;crqa&quot;, &quot;signal&quot;, &quot;sapa&quot;, &quot;ifultools&quot;, &quot;pracma&quot;, &quot;nlme&quot;, &quot;lme4&quot;, &quot;lmerTest&quot;, &quot;minpack.lm&quot;, &quot;igrpah&quot;,&quot;qgrap&quot;,&quot;graphicalVAR&quot;,&quot;bootGraph&quot;,&quot;IsingSampler&quot;,&quot;IsingFit&quot;), dependencies = TRUE) There is also a function library you need to source, the most recent version is on Github, use the devtools library to source the latest online version, or just follow the link, save as an .R file from your browser and open it in R and source it. library(devtools) source_url(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/functionLib/nlRtsa_SOURCE.R&quot;) 4.2.1 Importing data in R If you have package rio installed in R, you can load the data directly into the local environment. Follow the link, e.g. for series.sav. On the Github page, find a button marked Download (or Raw for textfiles). Copy the url associated with the Download button on Github (right-clik). The copied path should contain the word ‘raw’ somewhere in the url. Call import(url): series &lt;- import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/BasicTSA_arma/series.sav&quot;) You can use the function arima(), acf() and pacf() in R (Matlab has functions that go by slightly different names, check the Matlab Help pages). There are many extensions to these linear models, check the CRAN Task View on Time Series Analysis to learn more (e.g. about package zoo and forecast). | jump to solution | "],
["hrv.html", "4.3 Heartbeat dynamics", " 4.3 Heartbeat dynamics Download three different time series of heartbeat intervals (HBI) here. If you use R and have package rio installed you can run this code and the load the data into a data.frame directly from Github. library(rio) TS1 &lt;- rio::import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/RelativeRoughness/TS1.xlsx&quot;, col_names=FALSE) TS2 &lt;- rio::import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/RelativeRoughness/TS2.xlsx&quot;, col_names=FALSE) TS3 &lt;- rio::import(&quot;https://github.com/FredHasselman/DCS/raw/master/assignmentData/RelativeRoughness/TS3.xlsx&quot;, col_names=FALSE) The Excel files did not have any column names, so let’s create them in the data.frame colnames(TS1) &lt;- &quot;TS1&quot; colnames(TS2) &lt;- &quot;TS2&quot; colnames(TS3) &lt;- &quot;TS3&quot; 4.3.1 The recordings These HBI’s were constructed from the R-R intervals in electrocardiogram (ECG) recordings, as defined in Figure 4.1. Figure 4.1: Definition of Heart Beat Periods. One HBI series is a sample from a male adult, 62 years old (called Jimmy). Approximately two years before the recording, the subject has had a coronary artery bypass, as advised by his physician following a diagnosis of congestive heart failure. Jimmy used antiarrhythmic medicines at the time of measurement. Another HBI series is a sample from a healthy male adult, 21 years old (called Tommy). This subject never reported any cardiac complaint. Tommy was playing the piano during the recording. A third supposed HBI series is fictitious, and was never recorded from a human subject (let’s call this counterfeit Dummy). Your challenge The assignment is to scrutinise the data and find out which time series belongs to Jimmy, Tommy, and Dummy respectively.2 4.3.2 First inspection The chances that you are an experienced cardiologist are slim. We therefore suggest you proceed your detective work as follows: Construct a graphical representation of the time series, and inspect their dynamics visually (use the code examples provided in the solutions to previous sessions to plot your time series). Write down your first guesses about which time series belongs to which subject. Take your time for this visual inspection (i.e., which one looks more like a line than a plane, which one looks more ‘smooth’ than ‘rough’). Next, explore some measures of central tendency and dispersion, etc. Third, compute the Relative Roughness for each time series, use Equation (4.1) \\[\\begin{equation} RR = 2\\left[1−\\frac{\\gamma_1(x_i)}{Var(x_i)}\\right] \\tag{4.1} \\end{equation}\\] The numerator in the formula stands for the lag 1 autocovariance of the HBI time series \\(x_i\\). The denominator stands for the (global) variance of \\(x_i\\). Most statistics packages can calculate these variances, R and Matlab have built in functions. Alternatively, you can create the formula yourself. Compare your (intuitive) visual inspection with these preliminary dynamic quantifications, and find out where each of the HIB series are positions on the ‘colorful spectrum of noises’ (i.e., line them up with Figure 4.2). Figure 4.2: Coloured Noise versus Relative Roughness 4.3.3 What do we know now, that we didn’t knew before? Any updates on Jimmy’s, Tommy’s and Dummy’s health? You may start to wonder about the ‘meaning’ of these dynamics, and not find immediate answers. Don’t worry; we’ll cover the interpretation over the next two weeks in further depth. Let’s focus the dynamics just a little further for now. It might give you some clues. Use the randperm function (in Matlab or in package pracma in R) to randomize the temporal ordering of the HBI series. Visualize the resulting time series to check whether they were randomized successfully Next estimate the Relative Roughness of the randomized series. Did the estimates change compared to your previous outcomes (if so, why)? Now suppose you would repeat what you did the previous, but instead of using shuffle you would integrate the fictitious HBI series (i.e., normalize, then use x=cumsum(x)). You can look up cumsum in R or Matlab’s Help documentation). Would you get an estimate of Relative Roughness that is approximately comparable with what you got in another HBI series? If so, why? | jump to solution | The HBI intervals were truncated (not rounded) to a multiple of 10 ms (e.g., an interval of 0.457s is represented as 0.450s), and to 750 data points each. The means and standard deviations among the HBI series are approximately equidistant, which might complicate your challenge.↩ "],
["extra-creating-fractals-from-random-processes.html", "4.4 EXTRA: Creating fractals from random processes", " 4.4 EXTRA: Creating fractals from random processes Below are examples of so-called Iterated Function Systems, copy the code and run it in R (Matlab scripts are here) Try to understand what is going on in the two examples below. - How does the structure come about? We are drawing random numbers! - What’s the difference between the Siepinsky Gasket and the Fern? 4.4.1 A Triangle # Sierpinski Gasket using Iterated Function Systems # # RM-course Advanced Data Analysis # Module Dynamical and Nonlinear Data analysis and Modeling # # May 2008 # Fred Hasselman &amp; Ralf Cox require(dplyr) ## Loading required package: dplyr ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union x = 0 # Starting points y = 0 # Emppty plot plot(x,y, xlim=c(0,2), ylim=c(0,1)) for(i in 1:20000){ # This takes some time: 20.000 iterations coor=runif(1) # coor becomes a random number between 0 and 1 drawn from the uniform distribution # Equal chances (33%) to perform one of these 3 transformations of x and y if(coor&lt;=0.33){ x=0.5*x y=0.5*y points(x,y,pch=&quot;.&quot;, col=&quot;green&quot;) #plot these points in green } if(between(coor,0.33,0.66)){ x=0.5*x+0.5 y=0.5*y+0.5 points(x,y, pch=&quot;.&quot;, col=&quot;blue&quot;) # plot these points in blue } if(coor&gt;0.66){ x=0.5*x+1 y=0.5*y points(x,y, pch=&quot;.&quot;, col=&quot;red&quot;) #plot these points in red } } # for ... 4.4.2 A Fern # Barnsley&#39;s Fern using Iterated Function Systems # # RM-course Advanced Data Analysis # Module Dynamical and Nonlinear Data analysis and Modeling # # May 2008 # Fred Hasselman &amp; Ralf Cox require(dplyr) x = 0 # Starting points y = 0 # Emppty plot plot(x,y, pch=&quot;.&quot;, xlim=c(-3,3), ylim=c(0,12)) for(i in 1:50000){ # This takes some time: 20.000 iterations coor=runif(1) # coor becomes a random number between 0 and 1 drawn from the uniform distribution if(coor&lt;=0.01){ #This transformation 1% of the time x = 0 y = 0.16 * y points(x,y, pch=&quot;.&quot;, col=&quot;green3&quot;) } if(between(coor,0.01, 0.08)){ #This transformation 7% of the time x = 0.20 * x - 0.26 * y y = 0.23 * x + 0.22 * y + 1.6 points(x,y, pch=&quot;.&quot;, col=&quot;green2&quot;) } if(between(coor,0.08,0.15)){ #This transformation 7% of the time x = -0.15 * x + 0.28 * y y = 0.26 * x + 0.24 * y + 0.44 points(x,y, pch=&quot;.&quot;, col=&quot;springgreen3&quot;) } if(coor&gt;0.15){ #This transformation 85% of the time x = 0.85 * x + 0.04 * y y= -0.04 * x + 0.85 * y + 1.6 points(x,y, pch=&quot;.&quot;, col=&quot;springgreen2&quot;) } } # for ... 4.4.3 The fractal / chaos game These Iterated Function Systems also go by the name of ‘the fractal game’ and are used in computer science, the gaming industry, graphic design, etc. EXTRA-EXTRA: This Wikipedia page on Barnsley’s fern has some good info on the topic. At the end they display Mutant varieties. Try to implement them! You can by now probably guess that the these simple rules can be described as constraints on the degrees of freedom of the system. Like with the models of growth we simulated, the rules of the fractal game can be made dependent on other processes or events. A great example are the so-called fractal flames implemented in a screen-saver called electric sheep, which combines genetic algorithms, distributed computind and user input (“likes”) to create intruiging visual patterns on your computer screen.3 --> Use at your own risk! You will find yourself silently staring at the screen for longer periods of time.↩ "],
["fda1.html", "5 Fluctuation and Disperion analyses I", " 5 Fluctuation and Disperion analyses I Before you begin, look at the notes for Lecture 4. "],
["psd.html", "5.1 The Spectral Slope", " 5.1 The Spectral Slope We can use the power spectrum to estimate a self-affinity parameter, or scaling exponent. Download ts1.txt, ts2.txt, ts3.txt here. If you use R and have package rio installed you can run this code. It loads the data into a data.frame object directly from Github. library(rio) TS1 &lt;- rio::import(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/assignmentData/Fluctuation_PSDslope/ts1.txt&quot;) TS2 &lt;- rio::import(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/assignmentData/Fluctuation_PSDslope/ts2.txt&quot;) TS3 &lt;- rio::import(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/assignmentData/Fluctuation_PSDslope/ts3.txt&quot;) # These objects are now data.frames with one column named V1. # If you want to change the column names colnames(TS1) &lt;- &quot;TS1&quot; colnames(TS2) &lt;- &quot;TS2&quot; colnames(TS3) &lt;- &quot;TS3&quot; Plot the three ‘raw’ time series. 5.1.1 Basic data checks and preparations For spectral analysis we need to check some data assumptions (see notes on data preparation, Lecture 4). Normalize Are the lengths of the time series a power of 2? (Use log2(length of var) ) Computation of the frequency domain is greatly enhanced if data length is a power (of 2). Are the data normalized? (we will not remove datapoints outside 3SD) To normalize we have to subtract the mean from each value in the time series and divide it by the standard deviation, the function scale() can do this for you, but you could also use mean() and sd() to construct your own function. Plot the normalized time series. Detrend Before a spectral analysis you should remove any linear trends (it cannot deal with nonstationary signals!) Detrend the normalized data (just the linear trend). This can be done using the function pracma::detrend(). Extra: Try to figure out how to detrend the data using stats::lm() or stats::poly() Plot the detrended data. Get the log-log slope in Power Spectral Density The function fd.psd() will perform the spectral slope fitting procedure. Look at the manual pages to figure out how to call the function. The manual is on blackboard and Github Remember, we have already normalized and detrended the data. You can also look at the code itself by selecting the function name inR and pressing F2 Calculate the spectral slopes for the three normalized and detrended time series. Call with plot = TRUE Compare the results… What is your conclusion? | jump to solution | "],
["dfa.html", "5.2 DFA and SDA", " 5.2 DFA and SDA Use the functions fd.dfa() and fd.sda() to estimate the self-affinity parameter and Dimension of the series. Check what kind of data preparation is required for SDA and DFA in notes on data preparation, Lecture 4. Compare the results between the three different methods. | jump to solution | "],
["pacfrel.html", "5.3 ACF/PACF, Relative Roughness", " 5.3 ACF/PACF, Relative Roughness Also calculate the ACF, PACF (see assignment) and Relative Roughness Compare the results. | jump to solution | "],
["hrv2.html", "5.4 Heartbeat dynamics II", " 5.4 Heartbeat dynamics II In the previous assignment, you were presented with three different time series of heartbeat intervals (HBI), and you analyzed them using a measure of Relative Roughness (RR; cf. Marmelat &amp; Delignières, 2012). A logical step is to unleash the full force of your new analytic toolbox onto the HBI series. Keep track of the outcomes of each time series for 4 different analyses (RR, PSD, SDA, DFA). Do the outcomes of the different methods converge on the continuum of blue, white and pink, to Brownian and black noise? That is, do they indicate the same type of temporal structure? As a final step, construct return plots for each time series and try to interpret what you observe, given the outcomes of the scaling parameter estimates. | jump to solution | "],
["chaos.html", "5.5 Analysis of Deterministic Chaos", " 5.5 Analysis of Deterministic Chaos Generate a chaotic timeseries (e.g. \\(r = 4\\) ) of equal length as the time series used above (use the function growth.ac( ..., type = &quot;logistic&quot;) in nlRtsa_SOURCE, see the solutions of Lecture 1 and 2) This is in fact one of the series you analysed in a previous assignment. If you still have the results use them for the next part. Get all the scaling quantities for this series as well as the ACF and PACF and some return plots just like in the previous assignments. Compare the results to e.g. the heartbeat series. | jump to solution | -->"],
["fda2.html", "6 Fluctuation and Disperion analyses II", " 6 Fluctuation and Disperion analyses II There were no assignments for this Lecture. "],
["phase-space-reconstruction-and-rqa.html", "7 Phase Space Reconstruction and RQA", " 7 Phase Space Reconstruction and RQA You can use R or Matlab to run RQA analyses. These assignments assume you’ll use R. You can find a Matlab toolbox for RQA here: CRP toolbox For R you’ll probably need: library(rio) library(crqa) ## Loading required package: Matrix ## Loading required package: tseriesChaos ## Loading required package: deSolve ## Loading required package: fields ## Loading required package: spam ## Loading required package: grid ## Spam version 1.4-0 (2016-08-29) is loaded. ## Type &#39;help( Spam)&#39; or &#39;demo( spam)&#39; for a short introduction ## and overview of this package. ## Help for individual functions is also obtained by adding the ## suffix &#39;.spam&#39; to the function name, e.g. &#39;help( chol.spam)&#39;. ## ## Attaching package: &#39;spam&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## backsolve, forwardsolve ## Loading required package: maps ## Loading required package: plot3D ## Loading required package: pracma ## ## Attaching package: &#39;pracma&#39; ## The following object is masked from &#39;package:deSolve&#39;: ## ## rk4 ## The following objects are masked from &#39;package:Matrix&#39;: ## ## expm, lu, tril, triu library(fractal) ## Loading required package: splus2R ## ## Attaching package: &#39;splus2R&#39; ## The following object is masked from &#39;package:pracma&#39;: ## ## peaks ## Loading required package: ifultools library(devtools) source_url(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/functionLib/nlRtsa_SOURCE.R&quot;) ## SHA-1 hash of file is d5ddc9d83e98c51225244fe6634def33eaaba59e R-packages for Phase Space Reconstruction We’ll use package fractal and rgl to reconstruct some phase spaces. If you have sourced the functions in nlRtsa_SOURCE.R you can install and load these packages by running: in.IT(c(&quot;fractal&quot;,&quot;rgl&quot;)). The function in.IT() will first check if the requested packages are installed on the machine and only install them if they are not present. "],
["RQA.html", "7.1 Reconstruct the Lorenz attractor", " 7.1 Reconstruct the Lorenz attractor Package fractal includes the 3 dimensions of the Lorenz system in the chaotic regime. Run this code rgl::plot3d(lorenz) with both packages loaded to get an interactive 3D plot4 of this strange attractor. We’ll reconstruct the attractor based on just dimension X of the system using functions from package fractal, be sure to look at the manual pages of these functions. Package fractal and package nonlinearTseries use functions with similar names, do not load them together. Use lx &lt;- lorenz[1:2048,1] to reconstruct the phase space based on lx. Find an optimal embedding lag using timeLag(), use method = &quot;mutual&quot;. Find the embedding dimension, using FNN() Embed the timeseries using embedSeries(). Plot the reconstructed phase space. (You’ll need to use as.matrix() on the object created by embedSeries()) Use rgl::plot3d() to plot the reconstructed space. You’ll need the X Window System for interactive 3D plotting. This Linux desktop system comes installed in some way or form on most Mac and Windows systems.You can test if it is present by running rgl::open3d(), which will try to open an interactive plotting device↩ "],
["reconstruct-the-predator-prey-model.html", "7.2 Reconstruct the Predator-Prey model", " 7.2 Reconstruct the Predator-Prey model Use the same procedure as above to reconstruct the state space of the predator-prey system. (Look at the solutions to get a Foxes or Rabbit series). You should get a 2D state space, so 3D plotting might be a bit too much for this system. "],
["auto-recurrence-quantification-analysis.html", "7.3 (auto-) Recurrence Quantification Analysis", " 7.3 (auto-) Recurrence Quantification Analysis There are several packages which can perform (C)RQA analysis, we’ll use crqa because it can perform both continuous and categorical analyses. If you only have continuous data, you migh be better off using package nonlinearTseries, in this course we will only use package crqa. Package crqa() was designed to run categorical Cross-Recurrence Quantification Analysis (see Coco &amp; Dale (2014) and for R code see appendices in Coco &amp; Dale (2013)). We can trick it to run auto-RQA by providing the same timeseries for ts1 and ts2 and setting the parameter side to either &quot;upper&quot; or &quot;lower&quot; Perform an RQA on the reconstructed state space of the Lorenz system. You’ll need a radius (also called: threshold) in order to decide which points are close together (recurrent). crqa provides a function which will automatically select the best parameter settings: optimizeParam() Best way to ensure you are using the same parameters in each function is to create some lists with parameter settings (check the crqa manual to figure out what these parameters mean): # General settings for `crqa()` par0 &lt;- list(rescale = 1, normalize = 0, mindiagline = 2, minvertline = 2, tw = 0, whiteline = FALSE, recpt = FALSE, side = &quot;lower&quot;, checkl = list(do = FALSE, thrshd = 3, datatype = &quot;categorical&quot;,pad = TRUE) ) # Settings for `optimizeParam()` par &lt;- list(lgM = 20, steps = seq(1, 6, 1), radiusspan = 100, radiussample = 40, normalize = par0$normalize, rescale = par0$rescale, mindiagline = par0$mindiagline, minvertline = par0$minvertline, tw = par0$tw, whiteline = par0$whiteline, recpt = par0$recpt, fnnpercent = 10, typeami = &quot;mindip&quot;) Get the optimal parameters using a radius which will give us 2%-5% recurrent points. ans &lt;- optimizeParam(ts1 = lx, ts2 = lx, par = par, min.rec = 2, max.rec = 5) Run the RQA analysis using the same settings with which the parameters were found. crqaOutput &lt;- crqa(ts1 = lx, ts2 = lx, delay = ans$delay, embed = ans$emddim, radius = ans$radius, normalize = par0$normalize, rescale = par0$rescale, mindiagline = par0$mindiagline, minvertline = par0$minvertline, tw = par0$tw, whiteline = par0$whiteline, recpt = par0$recpt, side = par0$side, checkl = par0$checkl ) The output of crqa is a list with recurrence measures, the last entry is the recurrence plot. It is represented as a so-called sparse-matrix. This representation severely decreases the amount of memory occupied by the recurrence matrix. It is basically a list of indices of cells that contain a \\(1\\). The \\(0\\) do not need to be stored. In order to plot this matrix you could use image(), but this does not produce the recurrence plot as they are usually displayed, the y-axis needs to be flipped. We created a function which will take as input the list output of crqa, which wil be used to plot the recurrence matrix. If you have sourced the nlRtsa functions you can call plotRP.crqa(crqaOutput). | Jump to solutions | "],
["rqa-of-circle-tracing-data.html", "7.4 RQA of circle-tracing data", " 7.4 RQA of circle-tracing data Analyse the circle tracing data we recorded during the lecture. Study what happens to the RQA measures if you shuffle the temporal order (see e.g. the solution to th HRV assignments). Package fractal contains a function surrogate. This will create so-called constrained realisations of the time series. Look at the help pages of the function, or study the Surrogates Manual of the TISEAN software and create two surrogate series, one based on phase and one on aaft. Look at the RQA measures and think about which \\(H_0\\) should probably be rejected. If you want to be more certain, you’ll have to create a test (more surrogates). The TISEAN manual provides all the info you need to construct such a test: “For a minimal significance requirement of 95% , we thus need at least 19 or 39 surrogate time series for one- and two-sided tests, respectively. The conditions for rank based tests with more samples can be easily worked out. Using more surrogates can increase the discrimination power.” | Jump to solutions | -->"],
["categorical-and-cross-rqa-crqa.html", "8 Categorical and Cross-RQA (CRQA)", " 8 Categorical and Cross-RQA (CRQA) You can use R or Matlab to run RQA analyses. These assignments assume you’ll use R. You can find a Matlab toolbox for RQA here: CRP toolbox For R you’ll probably need: library(rio) library(crqa) library(fractal) library(devtools) source_url(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/functionLib/nlRtsa_SOURCE.R&quot;) "],
["CRQA.html", "8.1 Assignment: CRQA and Diagonal Profile", " 8.1 Assignment: CRQA and Diagonal Profile Create two variables for CRQA analysis, or use the \\(x\\) and \\(y\\) coordinates we roecorded during the lecture: y1 &lt;- sin(1:900*2*pi/67) y2 &lt;- sin(.01*(1:900*2*pi/67)^2) # Here are the circle trace data xy &lt;- import(&quot;https://raw.githubusercontent.com/FredHasselman/DCS/master/assignmentData/RQA_circletrace/mouse_circle_xy.csv&quot;) y1 &lt;- xy$x y2 &lt;- xy$y You have just created two sine(-like) waves. We’ll examine if and how they are coupled in a shared phase space. As a first step plot them. Find an embedding delay (using mutual information) and an embedding dimension (if you calculate an embedding dimension using package fractal for each signal seperately, as a rule of thumb use the highest embedding dimension you find in further analyses). # General settings for `crqa()` par0 &lt;- list(rescale = 0, normalize = 0, mindiagline = 2, minvertline = 2, tw = 0, whiteline = FALSE, recpt = FALSE, side = &quot;both&quot;, checkl = list(do = FALSE, thrshd = 3, datatype = &quot;categorical&quot;,pad = TRUE) ) # Settings for `optimizeParam()` par &lt;- list(lgM = 20, steps = seq(1, 6, 1), radiusspan = 100, radiussample = 40, normalize = par0$normalize, rescale = par0$rescale, mindiagline = par0$mindiagline, minvertline = par0$minvertline, tw = par0$tw, whiteline = par0$whiteline, recpt = par0$recpt, fnnpercent = 10, typeami = &quot;mindip&quot;) We can now create a cross recurrence matrix. Fill in the values you decided on. You can choose a radius automatically, look in the crqa manual. Get the optimal parameters using a radius which will give us 2%-5% recurrent points. Note: There is no rescaling of data, the sines were created in the same range. You can plot a matrix using image(). You could also check package nonlinearTseries. If you sourced the nlRtsa library, use plotRP.crqa() (ans &lt;- optimizeParam(ts1 = y1, ts2 = y2, par = par, min.rec = 2, max.rec = 5)) Run the CRQA and produce a plot of the recurrence matrix. Can you understand what is going on? For the simulated data: Explain the the lack of recurrent points at the beginning of the time series. For the circle trace: How could one see these are not determisnistic sine waves? Examine the synchronisation under the diagonal LOS. Look in the manual of crqa or Coco &amp; Dale (2014). To get the diagonal profile from the recurrence plot, use spdiags(). Make a plot of the diagonal profile. How far is the peak in RR removed from 0 (Line of Synchronisation)? Perform the same steps with a shuffled version (or use surrogate analysis!) of the data of timeseries \\(y1\\). You can use the embedding parameters you found earlier. NOTE: If you generate surrogate timeseries, make sure the RR is the same for all surrogates. Try to keep the RR in the same range by using the min.rec and max.rec settings of optimizeParam for each surrogate. | Jump to solutions | "],
["catCRQA.html", "8.2 Categorical CRQA", " 8.2 Categorical CRQA Package CRQA contains two categorical trial series from the “Friends”study. Lookup RDts1 and RDts2 in the help file. Also lookup the articles discussing the study to get an idea about these series here and here) In the paper accompanying the package by Coco &amp; Dale (2014) demonstrate the analysis of these series. Recreate this analysis, e.g. Figure 10 in the article including the CRQA measures. | Jump to solutions | -->"],
["cusp.html", "9 Potential and Catastrophe Models", " 9 Potential and Catastrophe Models The nonlinear regression assignment is written for SPSS, but you can try to use ‘R’ as well. Be sure to look at the solutions of the Basic Time Series Analysis) assignments. Using the cusp package "],
["fitting-the-cusp-catastrophe-in-spss.html", "9.1 Fitting the cusp catastrophe in SPSS", " 9.1 Fitting the cusp catastrophe in SPSS In the file Cusp Attitude.sav, you can find data from a (simulated) experiment. Assume the experiment tried to measure the effects of explicit predisposition and affective conditioning on attitudes towards Complexity Science measured in a sample of psychology students using a specially designed Implicit Attitude Test (IAT). Look at a Histogram of the difference score (post-pre) \\(dZY\\). This should look quite normal (pun intended). Perform a regular linear regression analysis predicting $dZY$ (Change in Attitude) from $\\alpha$ (Predisposition). Are you happy with the \\(R^2\\)? Look for Catastrophe Flags: Bimodality. Examine what the data look like if we split them across the conditions. Use \\(\\beta\\) (Conditioning) as a Split File Variable (Data &gt;&gt; Split File). And again, make a histogram of \\(dZY\\). Try to describe what you see in terms of the experiment. Turn Split File off. Make a Scatterplot of \\(dZY\\) (x-axis) and \\(\\alpha\\) (y-axis). Here you see the bimodality flag in a more dramatic fashion. Can you see another flag? Perhaps we should look at a cusp Catastrophe model: Go to Analyse &gt;&gt; Regression &gt;&gt; Nonlinear (also see Basic Time Series Analysis). First we need to tell SPSS which parameters we want to use, press Parameters. Now you can fill in the following: Intercept (Starting value \\(0.01\\)) B1 through B4 (Starting value \\(0.01\\)) Press Continue and use \\(dZY\\) as the dependent. Now we build the model in Model Expression, it should say this: Intercept + B1 * Beta * ZY1 + B2 * Alpha + B3 * ZY1 ** 2 + B4 * ZY1 ** 3 Run! And have a look at \\(R^2\\). The model can also be fitted with linear regression in SPSS, but we need to make some extra (nonlinear) variables using COMPUTE: BetaZY1 = Beta*ZY1 *(Bifurcation, splitting parameter). ZY1_2 = ZY1 ** 2 *(ZY1 Squared). ZY1_3 = ZY1 ** 3 *(ZY1 Cubed). Create a linear regression model with \\(dZY\\) as dependent and \\(Alpha\\), \\(BetaZY1\\) and \\(ZY1_2\\) en \\(ZY1_3\\) as predictors. Run! The parameter estimates should be the same. Finally try to can make a 3D-scatterplot with a smoother surface to have look at the response surface. HINT: this is a lot easier in R or Matlab perhaps you can export your SPSS solution. How to evaluate a fit? Check the last slides of lecture 8 in which the technique is summarised. The cusp has to outperform the pre-post model. "],
["the-cusp-package-in-r.html", "9.2 The cusp package in R", " 9.2 The cusp package in R Use this tutorial paper to fit the cusp in ‘R’ according to a maximum likelihood criterion. Grasman, R. P. P. P., Van der Maas, H. L. J., &amp; Wagenmakers, E. (2007). Fitting the Cusp Catastrophe in R: A cusp-Package. Start R and install package cusp Work through the Example I (attitude data) in the paper (Section 4: Examples, p. 12). Example II in the same section is also interesting, but is based on simulated data. Try to think of an application to psychological / behavioural science. -->"],
["nets.html", "10 Complex Networks", " 10 Complex Networks Have a look at the site Early Warning Systems "],
["using-the-ealy-warnings-r-package-in-r.html", "10.1 Using the ealy-warnings-r package in R", " 10.1 Using the ealy-warnings-r package in R -->"]
]
